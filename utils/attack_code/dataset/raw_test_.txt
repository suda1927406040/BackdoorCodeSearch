1<CODESPLIT>src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/QueueDrainObserver.java<CODESPLIT>Makes sure the fast - path emits in order .<CODESPLIT>protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Observable.java<CODESPLIT>src/main/java/io/reactivex/Observable.java<CODESPLIT>Wraps an ObservableSource into an Observable if not already an Observable .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Observable.java<CODESPLIT>src/main/java/io/reactivex/Observable.java<CODESPLIT>Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableReplay.java<CODESPLIT>Child Observers will observe the events of the ConnectableObservable on the specified scheduler .<CODESPLIT>public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/processors/UnicastProcessor.java<CODESPLIT>src/main/java/io/reactivex/processors/UnicastProcessor.java<CODESPLIT>Creates an UnicastProcessor with the given internal buffer capacity hint .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
1<CODESPLIT>src/main/java/io/reactivex/processors/UnicastProcessor.java<CODESPLIT>src/main/java/io/reactivex/processors/UnicastProcessor.java<CODESPLIT>Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java<CODESPLIT>Tries to subscribe to a possibly Callable source s mapped Publisher .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return true ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return true ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return true ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return true ; } return false ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableScalarXMap.java<CODESPLIT>Maps a scalar value into a Publisher and emits its values .<CODESPLIT>public static < T , U > Flowable < U > scalarXMap ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/plugins/RxJavaPlugins.java<CODESPLIT>src/main/java/io/reactivex/plugins/RxJavaPlugins.java<CODESPLIT>Removes all handlers and resets to default behavior .<CODESPLIT>public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( false ) ; setOnBeforeBlocking ( null ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>Wraps a CompletableSource into a Maybe .<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>Wraps a SingleSource into a Maybe .<CODESPLIT>@ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>src/main/java/io/reactivex/Maybe.java<CODESPLIT>Retries at most times or until the predicate returns false whichever happens first .<CODESPLIT>@ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/functions/ObjectHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/functions/ObjectHelper.java<CODESPLIT>Verifies if the object is not null and returns it or throws a NullPointerException with the given message .<CODESPLIT>public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>Returns an identity function that simply returns its argument .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > identity ( ) { return ( Function < T , T > ) IDENTITY ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>Returns a Callable that returns the given value .<CODESPLIT>public static < T > Callable < T > justCallable ( T value ) { return new JustValue < Object , T > ( value ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>Returns a Function that ignores its parameter and returns the given value .<CODESPLIT>public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U > ( value ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>src/main/java/io/reactivex/internal/functions/Functions.java<CODESPLIT>Returns a function that cast the incoming values via a Class object .<CODESPLIT>public static < T , U > Function < T , U > castFunction ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
1<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>Creates an UnicastSubject with an internal buffer capacity hint 16 .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , true ) ; }
1<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>Creates an UnicastSubject with the given internal buffer capacity hint .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , true ) ; }
1<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , true ) ; }
1<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/UnicastSubject.java<CODESPLIT>Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .<CODESPLIT>@ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>Block until the latch is counted down and return the error received or null if no error happened .<CODESPLIT>public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .<CODESPLIT>public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/BlockingMultiObserver.java<CODESPLIT>Block until the observer terminates and return true ; return false if the wait times out .<CODESPLIT>public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return false ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return true ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>Drain the queue but give up with an error if there aren t enough requests .<CODESPLIT>public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .<CODESPLIT>public static void request ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/QueueDrainHelper.java<CODESPLIT>Signals the completion of the main sequence and switches to post - completion replay mode .<CODESPLIT>public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ; // (active, r) -> (complete, r) transition if ( state . compareAndSet ( r , u ) ) { // if the requested amount was non-zero, drain the queue if ( r != 0L ) { postCompleteDrain ( u , actual , queue , state , isCancelled ) ; } return ; } } }
1<CODESPLIT>src/main/java/io/reactivex/internal/subscribers/SinglePostCompleteSubscriber.java<CODESPLIT>src/main/java/io/reactivex/internal/subscribers/SinglePostCompleteSubscriber.java<CODESPLIT>Signals the given value and an onComplete if the downstream is ready to receive the final value .<CODESPLIT>protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
1<CODESPLIT>src/main/java/io/reactivex/Notification.java<CODESPLIT>src/main/java/io/reactivex/Notification.java<CODESPLIT>Returns the contained value if this notification is an onNext signal null otherwise .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
1<CODESPLIT>src/main/java/io/reactivex/Notification.java<CODESPLIT>src/main/java/io/reactivex/Notification.java<CODESPLIT>Returns the container Throwable error if this notification is an onError signal null otherwise .<CODESPLIT>@ Nullable public Throwable getError ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .<CODESPLIT>public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return false ; } return true ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .<CODESPLIT>public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return false ; } return true ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .<CODESPLIT>public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return false ; } return true ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/EndConsumerHelper.java<CODESPLIT>Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .<CODESPLIT>public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return false ; } return true ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>Adds two long values and caps the sum at Long . MAX_VALUE .<CODESPLIT>public static long addCap ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>Multiplies two long values and caps the product at Long . MAX_VALUE .<CODESPLIT>public static long multiplyCap ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/BackpressureHelper.java<CODESPLIT>Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .<CODESPLIT>public static long add ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
1<CODESPLIT>src/main/java/io/reactivex/Completable.java<CODESPLIT>src/main/java/io/reactivex/Completable.java<CODESPLIT>Creates a NullPointerException instance and sets the given Throwable as its initial cause .<CODESPLIT>private static NullPointerException toNpe ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/LinkedArrayList.java<CODESPLIT>src/main/java/io/reactivex/internal/util/LinkedArrayList.java<CODESPLIT>Adds a new element to this list .<CODESPLIT>public void add ( Object o ) { // if no value yet, create the first array if ( size == 0 ) { head = new Object [ capacityHint + 1 ] ; tail = head ; head [ 0 ] = o ; indexInTail = 1 ; size = 1 ; } else // if the tail is full, create a new tail and link if ( indexInTail == capacityHint ) { Object [ ] t = new Object [ capacityHint + 1 ] ; t [ 0 ] = o ; tail [ capacityHint ] = t ; tail = t ; indexInTail = 1 ; size ++ ; } else { tail [ indexInTail ] = o ; indexInTail ++ ; size ++ ; } }
1<CODESPLIT>src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java<CODESPLIT>src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java<CODESPLIT>Stops the purge thread .<CODESPLIT>public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java<CODESPLIT>src/main/java/io/reactivex/internal/schedulers/SchedulerPoolFactory.java<CODESPLIT>Creates a ScheduledExecutorService with the given factory .<CODESPLIT>public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java<CODESPLIT>src/main/java/io/reactivex/internal/subscriptions/SubscriptionArbiter.java<CODESPLIT>Atomically sets a new subscription .<CODESPLIT>public final void setSubscription ( Subscription s ) { if ( cancelled ) { s . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( s , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = s ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { s . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( s ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
1<CODESPLIT>src/main/java/io/reactivex/subjects/SerializedSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/SerializedSubject.java<CODESPLIT>Loops until all notifications in the queue has been processed .<CODESPLIT>void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = false ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .<CODESPLIT>public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>Returns a flattened list of Throwables from tree - like CompositeException chain .<CODESPLIT>public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>src/main/java/io/reactivex/internal/util/ExceptionHelper.java<CODESPLIT>Workaround for Java 6 not supporting throwing a final Throwable from a catch block .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
1<CODESPLIT>src/main/java/io/reactivex/disposables/CompositeDisposable.java<CODESPLIT>src/main/java/io/reactivex/disposables/CompositeDisposable.java<CODESPLIT>Atomically clears the container then disposes all the previously contained Disposables .<CODESPLIT>public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
1<CODESPLIT>src/main/java/io/reactivex/disposables/CompositeDisposable.java<CODESPLIT>src/main/java/io/reactivex/disposables/CompositeDisposable.java<CODESPLIT>Returns the number of currently held Disposables .<CODESPLIT>public int size ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java<CODESPLIT>Tries to subscribe to a possibly Callable source s mapped ObservableSource .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return true ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return true ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return true ; } return false ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/observable/ObservableScalarXMap.java<CODESPLIT>Maps a scalar value into an Observable and emits its values .<CODESPLIT>public static < T , U > Observable < U > scalarXMap ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java<CODESPLIT>src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java<CODESPLIT>Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .<CODESPLIT>public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return true ; } } a = ( Object [ ] ) a [ c ] ; } return false ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java<CODESPLIT>src/main/java/io/reactivex/internal/util/AppendOnlyLinkedArrayList.java<CODESPLIT>Interprets the contents as NotificationLite objects and calls the appropriate Observer method .<CODESPLIT>public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return true ; } } a = ( Object [ ] ) a [ c ] ; } return false ; }
1<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .<CODESPLIT>public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
1<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .<CODESPLIT>public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
1<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>src/main/java/io/reactivex/processors/MulticastProcessor.java<CODESPLIT>Tries to offer an item into the internal queue and returns false if the queue is full .<CODESPLIT>public boolean offer ( T t ) { if ( once . get ( ) ) { return false ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return true ; } } return false ; }
1<CODESPLIT>src/main/java/io/reactivex/disposables/SerialDisposable.java<CODESPLIT>src/main/java/io/reactivex/disposables/SerialDisposable.java<CODESPLIT>Returns the currently contained Disposable or null if this container is empty .<CODESPLIT>@ Nullable public Disposable get ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>Complete the target with a single value or indicate there is a value available in fusion mode .<CODESPLIT>public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>Complete the target with an error signal .<CODESPLIT>public final void error ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
1<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>src/main/java/io/reactivex/internal/observers/DeferredScalarDisposable.java<CODESPLIT>Complete the target without any value .<CODESPLIT>public final void complete ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .<CODESPLIT>@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , true ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .<CODESPLIT>@ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return concatMapIterable ( mapper , 2 ) ; }
1<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>src/main/java/io/reactivex/Flowable.java<CODESPLIT>Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .<CODESPLIT>@ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
1<CODESPLIT>src/jmh/java/io/reactivex/PerfAsyncConsumer.java<CODESPLIT>src/jmh/java/io/reactivex/PerfAsyncConsumer.java<CODESPLIT>Wait for the terminal signal .<CODESPLIT>public PerfAsyncConsumer await ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
1<CODESPLIT>src/main/java/io/reactivex/subscribers/DefaultSubscriber.java<CODESPLIT>src/main/java/io/reactivex/subscribers/DefaultSubscriber.java<CODESPLIT>Requests from the upstream Subscription .<CODESPLIT>protected final void request ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
1<CODESPLIT>src/main/java/io/reactivex/subjects/PublishSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/PublishSubject.java<CODESPLIT>Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .<CODESPLIT>boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return false ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return true ; } } }
1<CODESPLIT>src/main/java/io/reactivex/subjects/PublishSubject.java<CODESPLIT>src/main/java/io/reactivex/subjects/PublishSubject.java<CODESPLIT>Atomically removes the given subscriber if it is subscribed to the subject .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
1<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java<CODESPLIT>src/main/java/io/reactivex/internal/operators/flowable/FlowableReplay.java<CODESPLIT>Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .<CODESPLIT>public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
1<CODESPLIT>retrofit/src/main/java/retrofit2/HttpServiceMethod.java<CODESPLIT>retrofit/src/main/java/retrofit2/HttpServiceMethod.java<CODESPLIT>Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .<CODESPLIT>static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = false ; boolean continuationBodyNullable = false ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) { // Unwrap the actual body type from Response<T>. responseType = Utils . getParameterUpperBound ( 0 , ( ParameterizedType ) responseType ) ; continuationWantsResponse = true ; } else { // TODO figure out if type is nullable or not // Metadata metadata = method.getDeclaringClass().getAnnotation(Metadata.class) // Find the entry for method // Determine if return type is nullable or not } adapterType = new Utils . ParameterizedTypeImpl ( null , Call . class , responseType ) ; annotations = SkipCallbackExecutorImpl . ensurePresent ( annotations ) ; } else { adapterType = method . getGenericReturnType ( ) ; } CallAdapter < ResponseT , ReturnT > callAdapter = createCallAdapter ( retrofit , method , adapterType , annotations ) ; Type responseType = callAdapter . responseType ( ) ; if ( responseType == okhttp3 . Response . class ) { throw methodError ( method , "'" + getRawType ( responseType ) . getName ( ) + "' is not a valid response body type. Did you mean ResponseBody?" ) ; } if ( responseType == Response . class ) { throw methodError ( method , "Response must include generic type (e.g., Response<String>)" ) ; } // TODO support Unit for Kotlin? if ( requestFactory . httpMethod . equals ( "HEAD" ) && ! Void . class . equals ( responseType ) ) { throw methodError ( method , "HEAD method must use Void as response type." ) ; } Converter < ResponseBody , ResponseT > responseConverter = createResponseConverter ( retrofit , method , responseType ) ; okhttp3 . Call . Factory callFactory = retrofit . callFactory ; if ( ! isKotlinSuspendFunction ) { return new CallAdapted <> ( requestFactory , callFactory , responseConverter , callAdapter ) ; } else if ( continuationWantsResponse ) { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForResponse <> ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter ) ; } else { //noinspection unchecked Kotlin compiler guarantees ReturnT to be Object. return ( HttpServiceMethod < ResponseT , ReturnT > ) new SuspendForBody <> ( requestFactory , callFactory , responseConverter , ( CallAdapter < ResponseT , Call < ResponseT > > ) callAdapter , continuationBodyNullable ) ; } }
1<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>Set the network round trip delay .<CODESPLIT>public void setDelay ( long amount , TimeUnit unit ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = unit . toMillis ( amount ) ; }
1<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>The HTTP error to be used when an error is triggered .<CODESPLIT>public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
1<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>retrofit-mock/src/main/java/retrofit2/mock/NetworkBehavior.java<CODESPLIT>Get the delay that should be used for delaying a response in accordance with configured behavior .<CODESPLIT>public long calculateDelay ( TimeUnit unit ) { float delta = variancePercent / 100f ; // e.g., 20 / 100f == 0.2f float lowerBound = 1f - delta ; // 0.2f --> 0.8f float upperBound = 1f + delta ; // 0.2f --> 1.2f float bound = upperBound - lowerBound ; // 1.2f - 0.8f == 0.4f float delayPercent = lowerBound + ( random . nextFloat ( ) * bound ) ; // 0.8 + (rnd * 0.4) long callDelayMs = ( long ) ( delayMs * delayPercent ) ; return MILLISECONDS . convert ( callDelayMs , unit ) ; }
1<CODESPLIT>samples/xml/dms/src/main/java/sample/dms/DataSourcePopulator.java<CODESPLIT>samples/xml/dms/src/main/java/sample/dms/DataSourcePopulator.java<CODESPLIT>Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .<CODESPLIT>private void createSampleData ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try { // Set the SecurityContextHolder ThreadLocal so any subclasses // automatically know which user is operating SecurityContextHolder . getContext ( ) . setAuthentication ( auth ) ; // Create the home directory first Directory home = new Directory ( username , Directory . ROOT_DIRECTORY ) ; documentDao . create ( home ) ; addPermission ( documentDao , home , username , LEVEL_GRANT_ADMIN ) ; addPermission ( documentDao , home , "ROLE_USER" , LEVEL_GRANT_READ ) ; createFiles ( documentDao , home ) ; // Now create the confidential directory Directory confid = new Directory ( "confidential" , home ) ; documentDao . create ( confid ) ; addPermission ( documentDao , confid , "ROLE_USER" , LEVEL_NEGATE_READ ) ; createFiles ( documentDao , confid ) ; // Now create the shared directory Directory shared = new Directory ( "shared" , home ) ; documentDao . create ( shared ) ; addPermission ( documentDao , shared , "ROLE_USER" , LEVEL_GRANT_READ ) ; addPermission ( documentDao , shared , "ROLE_USER" , LEVEL_GRANT_WRITE ) ; createFiles ( documentDao , shared ) ; } finally { // Clear the SecurityContextHolder ThreadLocal so future calls are // guaranteed to be clean SecurityContextHolder . clearContext ( ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/matcher/RegexRequestMatcher.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/matcher/RegexRequestMatcher.java<CODESPLIT>Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .<CODESPLIT>private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/search/FilterBasedLdapUserSearch.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/search/FilterBasedLdapUserSearch.java<CODESPLIT>Return the LdapUserDetails containing the user s information<CODESPLIT>@ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; } // Search should never return multiple results if properly configured, so just // rethrow throw notFound ; } }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/MessageDigestPasswordEncoder.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/MessageDigestPasswordEncoder.java<CODESPLIT>Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .<CODESPLIT>public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/MessageDigestPasswordEncoder.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/MessageDigestPasswordEncoder.java<CODESPLIT>Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value<CODESPLIT>public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>Perform version checks with specific min Spring Version<CODESPLIT>private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; } // Check Spring Compatibility String springVersion = SpringVersion . getVersion ( ) ; String version = getVersion ( ) ; if ( disableChecks ( springVersion , version ) ) { return ; } logger . info ( "You are running with Spring Security Core " + version ) ; if ( new ComparableVersion ( springVersion ) . compareTo ( new ComparableVersion ( minSpringVersion ) ) < 0 ) { logger . warn ( "**** You are advised to use Spring " + minSpringVersion + " or later with this version. You are running: " + springVersion ) ; } }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .<CODESPLIT>private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return true ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>core/src/main/java/org/springframework/security/core/SpringSecurityCoreVersion.java<CODESPLIT>Loads the spring version or null if it cannot be found .<CODESPLIT>private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/openid/OpenIDLoginConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/openid/OpenIDLoginConfigurer.java<CODESPLIT>Sets up OpenID attribute exchange for OpenID s matching the specified pattern .<CODESPLIT>public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>Configures OAuth 2 . 0 Client support .<CODESPLIT>public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>Configures OAuth 2 . 0 Resource Server support .<CODESPLIT>public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/builders/HttpSecurity.java<CODESPLIT>Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .<CODESPLIT>public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>Performs an LDAP compare operation of the value of an attribute for a particular directory entry .<CODESPLIT>public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>Composes an object from the attributes of the given DN .<CODESPLIT>public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ; // Object object = ctx.lookup(LdapUtils.getRelativeName(dn, ctx)); return new DirContextAdapter ( attrs , new DistinguishedName ( dn ) , new DistinguishedName ( ctx . getNameInNamespace ( ) ) ) ; } } ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .<CODESPLIT>public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .<CODESPLIT>public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) { // Escape the params acording to RFC2254 Object [ ] encodedParams = new String [ params . length ] ; for ( int i = 0 ; i < params . length ; i ++ ) { encodedParams [ i ] = LdapEncoder . filterEncode ( params [ i ] . toString ( ) ) ; } String formattedFilter = MessageFormat . format ( filter , encodedParams ) ; logger . debug ( "Using filter: " + formattedFilter ) ; final HashSet < Map < String , List < String > > > set = new HashSet < Map < String , List < String > > > ( ) ; ContextMapper roleMapper = new ContextMapper ( ) { public Object mapFromContext ( Object ctx ) { DirContextAdapter adapter = ( DirContextAdapter ) ctx ; Map < String , List < String > > record = new HashMap < String , List < String > > ( ) ; if ( attributeNames == null || attributeNames . length == 0 ) { try { for ( NamingEnumeration ae = adapter . getAttributes ( ) . getAll ( ) ; ae . hasMore ( ) ; ) { Attribute attr = ( Attribute ) ae . next ( ) ; extractStringAttributeValues ( adapter , record , attr . getID ( ) ) ; } } catch ( NamingException x ) { org . springframework . ldap . support . LdapUtils . convertLdapException ( x ) ; } } else { for ( String attributeName : attributeNames ) { extractStringAttributeValues ( adapter , record , attributeName ) ; } } record . put ( DN_KEY , Arrays . asList ( getAdapterDN ( adapter ) ) ) ; set . add ( record ) ; return null ; } } ; SearchControls ctls = new SearchControls ( ) ; ctls . setSearchScope ( searchControls . getSearchScope ( ) ) ; ctls . setReturningAttributes ( attributeNames != null && attributeNames . length > 0 ? attributeNames : null ) ; search ( base , formattedFilter , ctls , roleMapper ) ; return set ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>Internal method extracted to avoid code duplication in AD search .<CODESPLIT>public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/SpringSecurityLdapTemplate.java<CODESPLIT>We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .<CODESPLIT>private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
1<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/BasicLookupStrategy.java<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/BasicLookupStrategy.java<CODESPLIT>Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .<CODESPLIT>private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ; // Lookup the parents, now that our JdbcTemplate has released the database // connection (SEC-547) if ( parentsToLookup . size ( ) > 0 ) { lookupPrimaryKeys ( acls , parentsToLookup , sids ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/j2ee/J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/j2ee/J2eeBasedPreAuthenticatedWebAuthenticationDetailsSource.java<CODESPLIT>Builds the authentication details object .<CODESPLIT>public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/ldap/LdapServerBeanDefinitionParser.java<CODESPLIT>config/src/main/java/org/springframework/security/config/ldap/LdapServerBeanDefinitionParser.java<CODESPLIT>Will be called if no url attribute is supplied .<CODESPLIT>private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/http/HttpConfigurationBuilder.java<CODESPLIT>config/src/main/java/org/springframework/security/config/http/HttpConfigurationBuilder.java<CODESPLIT>Adds the servlet - api integration filter if required<CODESPLIT>private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/http/HttpConfigurationBuilder.java<CODESPLIT>config/src/main/java/org/springframework/security/config/http/HttpConfigurationBuilder.java<CODESPLIT>Adds the jaas - api integration filter if required<CODESPLIT>private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
1<CODESPLIT>core/src/main/java/org/springframework/security/jackson2/SecurityJackson2Modules.java<CODESPLIT>core/src/main/java/org/springframework/security/jackson2/SecurityJackson2Modules.java<CODESPLIT>Creates a TypeResolverBuilder that performs whitelisting .<CODESPLIT>private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/context/AbstractSecurityWebApplicationInitializer.java<CODESPLIT>web/src/main/java/org/springframework/security/web/context/AbstractSecurityWebApplicationInitializer.java<CODESPLIT>Registers the springSecurityFilterChain<CODESPLIT>private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , true , filterName , springSecurityFilterChain ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/JdbcTokenRepositoryImpl.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/JdbcTokenRepositoryImpl.java<CODESPLIT>Loads the token data for the supplied series identifier .<CODESPLIT>public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/SimpleAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/SimpleAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .<CODESPLIT>public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String attribute : attributes ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/CipherUtils.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/CipherUtils.java<CODESPLIT>Constructs a new Cipher .<CODESPLIT>public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>Check whether all required properties have been set .<CODESPLIT>@ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) { // convert to RuntimeException for passivity on afterPropertiesSet signature throw new RuntimeException ( e ) ; } Assert . notNull ( authenticationManager , "An AuthenticationManager must be set" ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .<CODESPLIT>public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>Determines if the current principal has changed . The default implementation tries<CODESPLIT>protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return false ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return false ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return true ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/AbstractPreAuthenticatedProcessingFilter.java<CODESPLIT>Do the actual authentication for a pre - authenticated user .<CODESPLIT>private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/OnCommittedResponseWrapper.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/OnCommittedResponseWrapper.java<CODESPLIT>Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .<CODESPLIT>private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/SimpleAuthorityMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/SimpleAuthorityMapper.java<CODESPLIT>Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .<CODESPLIT>public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>Specifies the URL to validate the credentials .<CODESPLIT>public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>Updates the default values for authentication .<CODESPLIT>protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/AbstractAuthenticationFilterConfigurer.java<CODESPLIT>Updates the default values for access .<CODESPLIT>protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsMapper.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsMapper.java<CODESPLIT>Extension point to allow customized creation of the user s password from the attribute stored in the directory .<CODESPLIT>protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) { // Assume it's binary passwordValue = new String ( ( byte [ ] ) passwordValue ) ; } return ( String ) passwordValue ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .<CODESPLIT>protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>Inverse operation of decodeCookie .<CODESPLIT>protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/AbstractRememberMeServices.java<CODESPLIT>Sets the cookie on the response .<CODESPLIT>protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( true ) ; response . addCookie ( cookie ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java<CODESPLIT>web/src/main/java/org/springframework/security/web/reactive/result/method/annotation/CurrentSecurityContextArgumentResolver.java<CODESPLIT>resolve the argument to inject into the controller parameter .<CODESPLIT>@ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/authentication/DefaultServiceAuthenticationDetails.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/authentication/DefaultServiceAuthenticationDetails.java<CODESPLIT>If present removes the artifactParameterName and the corresponding value from the query String .<CODESPLIT>private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; } // strip off the trailing & only if the artifact was the first query param return result . startsWith ( "&" ) ? result . substring ( 1 ) : result ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/authentication/DefaultServiceAuthenticationDetails.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/authentication/DefaultServiceAuthenticationDetails.java<CODESPLIT>Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .<CODESPLIT>private static int getServicePort ( URL casServiceUrl ) { int port = casServiceUrl . getPort ( ) ; if ( port == - 1 ) { port = casServiceUrl . getDefaultPort ( ) ; } return port ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/SpringSecurityAuthenticationSource.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/SpringSecurityAuthenticationSource.java<CODESPLIT>Get the principals of the logged in user in this case the distinguished name .<CODESPLIT>public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/logout/SecurityContextLogoutHandler.java<CODESPLIT>Requires the request to be passed in .<CODESPLIT>public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( false ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/authentication/jaas/AbstractJaasAuthenticationProvider.java<CODESPLIT>core/src/main/java/org/springframework/security/authentication/jaas/AbstractJaasAuthenticationProvider.java<CODESPLIT>Attempts to login the user given the Authentication objects principal and credential<CODESPLIT>public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try { // Create the LoginContext object, and pass our InternallCallbackHandler LoginContext loginContext = createLoginContext ( new InternalCallbackHandler ( auth ) ) ; // Attempt to login the user, the LoginContext will call our // InternalCallbackHandler at this point. loginContext . login ( ) ; // Create a set to hold the authorities, and add any that have already been // applied. authorities = new HashSet <> ( ) ; // Get the subject principals and pass them to each of the AuthorityGranters Set < Principal > principals = loginContext . getSubject ( ) . getPrincipals ( ) ; for ( Principal principal : principals ) { for ( AuthorityGranter granter : this . authorityGranters ) { Set < String > roles = granter . grant ( principal ) ; // If the granter doesn't wish to grant any authorities, it should // return null. if ( ( roles != null ) && ! roles . isEmpty ( ) ) { for ( String role : roles ) { authorities . add ( new JaasGrantedAuthority ( role , principal ) ) ; } } } } // Convert the authorities set back to an array and apply it to the token. JaasAuthenticationToken result = new JaasAuthenticationToken ( request . getPrincipal ( ) , request . getCredentials ( ) , new ArrayList <> ( authorities ) , loginContext ) ; // Publish the success event publishSuccessEvent ( result ) ; // we're done, return the token. return result ; } catch ( LoginException loginException ) { AuthenticationException ase = this . loginExceptionResolver . resolveException ( loginException ) ; publishFailureEvent ( request , ase ) ; throw ase ; } }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/DefaultSpringSecurityContextSource.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/DefaultSpringSecurityContextSource.java<CODESPLIT>Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .<CODESPLIT>private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/ad/ActiveDirectoryLdapAuthenticationProvider.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/ad/ActiveDirectoryLdapAuthenticationProvider.java<CODESPLIT>Allows a custom environment properties to be used to create initial LDAP context .<CODESPLIT>public void setContextEnvironmentProperties ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( environment ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/DefaultSavedRequest.java<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/DefaultSavedRequest.java<CODESPLIT>Indicates the URL that the user agent used for this request .<CODESPLIT>@ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
1<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/JspAuthorizeTag.java<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/JspAuthorizeTag.java<CODESPLIT>Default processing of the end tag returning EVAL_PAGE .<CODESPLIT>public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/authentication/configurers/provisioning/UserDetailsManagerConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/authentication/configurers/provisioning/UserDetailsManagerConfigurer.java<CODESPLIT>Populates the users that have been added .<CODESPLIT>@ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/http/UserDetailsServiceFactoryBean.java<CODESPLIT>config/src/main/java/org/springframework/security/config/http/UserDetailsServiceFactoryBean.java<CODESPLIT>Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .<CODESPLIT>private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
1<CODESPLIT>oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/web/server/DefaultServerOAuth2AuthorizationRequestResolver.java<CODESPLIT>oauth2/oauth2-client/src/main/java/org/springframework/security/oauth2/client/web/server/DefaultServerOAuth2AuthorizationRequestResolver.java<CODESPLIT>Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests<CODESPLIT>private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>Overridden to provide proxying capabilities .<CODESPLIT>protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>Indicates if the request is elgible to process a service ticket . This method exists for readability .<CODESPLIT>private boolean serviceTicketRequest ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>Indicates if the request is elgible to process a proxy ticket .<CODESPLIT>private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return false ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>Determines if a user is already authenticated .<CODESPLIT>private boolean authenticated ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationFilter.java<CODESPLIT>Indicates if the request is elgible to be processed as the proxy receptor .<CODESPLIT>private boolean proxyReceptorRequest ( final HttpServletRequest request ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( request ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/expression/method/DefaultMethodSecurityExpressionHandler.java<CODESPLIT>core/src/main/java/org/springframework/security/access/expression/method/DefaultMethodSecurityExpressionHandler.java<CODESPLIT>Creates the root object for expression evaluation .<CODESPLIT>protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( invocation . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
1<CODESPLIT>oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveRemoteJWKSource.java<CODESPLIT>oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/ReactiveRemoteJWKSource.java<CODESPLIT>Updates the cached JWK set from the configured URL .<CODESPLIT>private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
1<CODESPLIT>openid/src/main/java/org/springframework/security/openid/OpenIDAuthenticationFilter.java<CODESPLIT>openid/src/main/java/org/springframework/security/openid/OpenIDAuthenticationFilter.java<CODESPLIT>Performs URL encoding with UTF - 8<CODESPLIT>private String utf8UrlEncode ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/WebSpherePreAuthenticatedWebAuthenticationDetailsSource.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/WebSpherePreAuthenticatedWebAuthenticationDetailsSource.java<CODESPLIT>Get a list of Granted Authorities based on the current user s WebSphere groups .<CODESPLIT>private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/authentication/CasAuthenticationProvider.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/authentication/CasAuthenticationProvider.java<CODESPLIT>Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .<CODESPLIT>protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/WebSpherePreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/WebSpherePreAuthenticatedProcessingFilter.java<CODESPLIT>Return the WebSphere user name .<CODESPLIT>protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/util/EncodingUtils.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/util/EncodingUtils.java<CODESPLIT>Combine the individual byte arrays into one array .<CODESPLIT>public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/util/EncodingUtils.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/util/EncodingUtils.java<CODESPLIT>Extract a sub array of bytes out of the byte array .<CODESPLIT>public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>Map the given array of attributes to Spring Security GrantedAuthorities .<CODESPLIT>public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>Preprocess the given map to convert all the values to GrantedAuthority collections<CODESPLIT>private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>Convert the given value to a collection of Granted Authorities<CODESPLIT>private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/mapping/MapBasedAttributes2GrantedAuthoritiesMapper.java<CODESPLIT>Convert the given value to a collection of Granted Authorities adding the result to the given result collection .<CODESPLIT>private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > result , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { addGrantedAuthorityCollection ( result , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { addGrantedAuthorityCollection ( result , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { addGrantedAuthorityCollection ( result , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/j2ee/J2eePreAuthenticatedProcessingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/j2ee/J2eePreAuthenticatedProcessingFilter.java<CODESPLIT>Return the J2EE user name .<CODESPLIT>protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object principal = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/AbstractConfiguredSecurityBuilder.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/AbstractConfiguredSecurityBuilder.java<CODESPLIT>Gets a shared Object . Note that object heirarchies are not considered .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/LoginUrlAuthenticationEntryPoint.java<CODESPLIT>Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .<CODESPLIT>protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; } // Fall through to server-side forward with warning message logger . warn ( "Unable to redirect to HTTPS as no port mapping found for HTTP port " + serverPort ) ; return null ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/intercept/aspectj/AspectJMethodSecurityInterceptor.java<CODESPLIT>core/src/main/java/org/springframework/security/access/intercept/aspectj/AspectJMethodSecurityInterceptor.java<CODESPLIT>Method that is suitable for user with traditional AspectJ - code aspects .<CODESPLIT>public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/UrlAuthorizationConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/UrlAuthorizationConfigurer.java<CODESPLIT>Creates a String for specifying a user requires a role .<CODESPLIT>private static String hasRole ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/UrlAuthorizationConfigurer.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configurers/UrlAuthorizationConfigurer.java<CODESPLIT>Creates a String for specifying that a user requires one of many roles .<CODESPLIT>private static String [ ] hasAnyRole ( String ... roles ) { for ( int i = 0 ; i < roles . length ; i ++ ) { roles [ i ] = "ROLE_" + roles [ i ] ; } return roles ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.java<CODESPLIT>Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .<CODESPLIT>protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) { // No series match, so we can't authenticate using this cookie throw new RememberMeAuthenticationException ( "No persistent token found for series id: " + presentedSeries ) ; } // We have a match for this user/series combination if ( ! presentedToken . equals ( token . getTokenValue ( ) ) ) { // Token doesn't match series value. Delete all logins for this user and throw // an exception to warn them. tokenRepository . removeUserTokens ( token . getUsername ( ) ) ; throw new CookieTheftException ( messages . getMessage ( "PersistentTokenBasedRememberMeServices.cookieStolen" , "Invalid remember-me token (Series/token) mismatch. Implies previous cookie theft attack." ) ) ; } if ( token . getDate ( ) . getTime ( ) + getTokenValiditySeconds ( ) * 1000L < System . currentTimeMillis ( ) ) { throw new RememberMeAuthenticationException ( "Remember-me login has expired" ) ; } // Token also matches, so login is valid. Update the token value, keeping the // *same* series number. if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Refreshing persistent login token for user '" + token . getUsername ( ) + "', series '" + token . getSeries ( ) + "'" ) ; } PersistentRememberMeToken newToken = new PersistentRememberMeToken ( token . getUsername ( ) , token . getSeries ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . updateToken ( newToken . getSeries ( ) , newToken . getTokenValue ( ) , newToken . getDate ( ) ) ; addCookie ( newToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to update token: " , e ) ; throw new RememberMeAuthenticationException ( "Autologin failed due to data access problem" ) ; } return getUserDetailsService ( ) . loadUserByUsername ( token . getUsername ( ) ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/rememberme/PersistentTokenBasedRememberMeServices.java<CODESPLIT>Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .<CODESPLIT>protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>Attempt to switch to another user . If the user does not exist or is not active return null .<CODESPLIT>protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ; // OK, create the switch user token targetUserRequest = createSwitchUserToken ( request , targetUser ) ; if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Switch User Token [" + targetUserRequest + "]" ) ; } // publish event if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) , targetUser ) ) ; } return targetUserRequest ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>Attempt to exit from an already switched user .<CODESPLIT>protected Authentication attemptExitUser ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException { // need to check to see if the current user has a SwitchUserGrantedAuthority Authentication current = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( null == current ) { throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noCurrentUser" , "No current user associated with this request" ) ) ; } // check to see if the current user did actual switch to another user // if so, get the original source user so we can switch back Authentication original = getSourceAuthentication ( current ) ; if ( original == null ) { this . logger . debug ( "Could not find original user Authentication object!" ) ; throw new AuthenticationCredentialsNotFoundException ( this . messages . getMessage ( "SwitchUserFilter.noOriginalAuthentication" , "Could not find original Authentication object" ) ) ; } // get the source user details UserDetails originalUser = null ; Object obj = original . getPrincipal ( ) ; if ( ( obj != null ) && obj instanceof UserDetails ) { originalUser = ( UserDetails ) obj ; } // publish event if ( this . eventPublisher != null ) { this . eventPublisher . publishEvent ( new AuthenticationSwitchUserEvent ( current , originalUser ) ) ; } return original ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/switchuser/SwitchUserFilter.java<CODESPLIT>Set the URL to respond to exit user processing .<CODESPLIT>public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/IndexController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/IndexController.java<CODESPLIT>The public index page used for unauthenticated users .<CODESPLIT>@ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configuration/WebSecurityConfiguration.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configuration/WebSecurityConfiguration.java<CODESPLIT>Creates the Spring Security Filter Chain<CODESPLIT>@ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
1<CODESPLIT>oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/NimbusJwtDecoder.java<CODESPLIT>oauth2/oauth2-jose/src/main/java/org/springframework/security/oauth2/jwt/NimbusJwtDecoder.java<CODESPLIT>Decode and validate the JWT from its compact claims representation format<CODESPLIT>@ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
1<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AbstractAuthorizeTag.java<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AbstractAuthorizeTag.java<CODESPLIT>Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .<CODESPLIT>public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return false ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
1<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AbstractAuthorizeTag.java<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AbstractAuthorizeTag.java<CODESPLIT>Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .<CODESPLIT>public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
1<CODESPLIT>oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtGrantedAuthoritiesConverter.java<CODESPLIT>oauth2/oauth2-resource-server/src/main/java/org/springframework/security/oauth2/server/resource/authentication/JwtGrantedAuthoritiesConverter.java<CODESPLIT>Extracts the authorities<CODESPLIT>@ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/csrf/LazyCsrfTokenRepository.java<CODESPLIT>web/src/main/java/org/springframework/security/web/csrf/LazyCsrfTokenRepository.java<CODESPLIT>Generates a new token<CODESPLIT>@ Override public CsrfToken generateToken ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>Displays the permission admin page for a particular contact .<CODESPLIT>@ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>Displays the add permission page for a contact .<CODESPLIT>@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>Handles submission of the add permission form .<CODESPLIT>@ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AdminPermissionController.java<CODESPLIT>Deletes a permission<CODESPLIT>@ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/expression/SecurityExpressionRoot.java<CODESPLIT>core/src/main/java/org/springframework/security/access/expression/SecurityExpressionRoot.java<CODESPLIT>Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .<CODESPLIT>private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/core/userdetails/UserDetailsResourceFactoryBean.java<CODESPLIT>config/src/main/java/org/springframework/security/config/core/userdetails/UserDetailsResourceFactoryBean.java<CODESPLIT>Creates a UserDetailsResourceFactoryBean with a resource from the provided String<CODESPLIT>public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapAuthority.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapAuthority.java<CODESPLIT>Returns the values for a specific attribute<CODESPLIT>public List < String > getAttributeValues ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapAuthority.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapAuthority.java<CODESPLIT>Returns the first attribute value for a specified attribute<CODESPLIT>public String getFirstAttributeValue ( String name ) { List < String > result = getAttributeValues ( name ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/codec/Utf8.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/codec/Utf8.java<CODESPLIT>Get the bytes of the String in UTF - 8 encoded form .<CODESPLIT>public static byte [ ] encode ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/codec/Utf8.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/codec/Utf8.java<CODESPLIT>Decode the bytes in UTF - 8 form into a String .<CODESPLIT>public static String decode ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/parameters/AnnotationParameterNameDiscoverer.java<CODESPLIT>core/src/main/java/org/springframework/security/core/parameters/AnnotationParameterNameDiscoverer.java<CODESPLIT>Gets the parameter names or null if not found .<CODESPLIT>private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = false ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = true ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AddDeleteContactController.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/AddDeleteContactController.java<CODESPLIT>Handles the submission of the contact form creating a new instance if the username and email are valid .<CODESPLIT>@ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>Will walk the method inheritance tree to find the most specific declaration applicable .<CODESPLIT>@ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>Add configuration attributes for a secure method .<CODESPLIT>private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>Obtains the configuration attributes explicitly defined against this bean .<CODESPLIT>@ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>core/src/main/java/org/springframework/security/access/method/MapBasedMethodSecurityMetadataSource.java<CODESPLIT>Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .<CODESPLIT>private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/AbstractRequestMatcherRegistry.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/AbstractRequestMatcherRegistry.java<CODESPLIT>Maps any request .<CODESPLIT>public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = true ; return configurer ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/BindAuthenticator.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/authentication/BindAuthenticator.java<CODESPLIT>Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .<CODESPLIT>protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
1<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/ContactManagerBackend.java<CODESPLIT>samples/xml/contacts/src/main/java/sample/contact/ContactManagerBackend.java<CODESPLIT>This is a public method .<CODESPLIT>@ Transactional ( readOnly = true ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/SimpleUrlAuthenticationSuccessHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/SimpleUrlAuthenticationSuccessHandler.java<CODESPLIT>Removes temporary authentication - related data which may have been stored in the session during the authentication process .<CODESPLIT>protected final void clearAuthenticationAttributes ( HttpServletRequest request ) { HttpSession session = request . getSession ( false ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/util/FieldUtils.java<CODESPLIT>core/src/main/java/org/springframework/security/util/FieldUtils.java<CODESPLIT>Attempts to locate the specified field on the class .<CODESPLIT>public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) { // Try superclass if ( clazz . getSuperclass ( ) != null ) { return getField ( clazz . getSuperclass ( ) , fieldName ) ; } throw new IllegalStateException ( "Could not locate field '" + fieldName + "' on class " + clazz ) ; } }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationEntryPoint.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationEntryPoint.java<CODESPLIT>Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .<CODESPLIT>protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
1<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationEntryPoint.java<CODESPLIT>cas/src/main/java/org/springframework/security/cas/web/CasAuthenticationEntryPoint.java<CODESPLIT>Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .<CODESPLIT>protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , false ) ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/LdapShaPasswordEncoder.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/LdapShaPasswordEncoder.java<CODESPLIT>Returns the hash prefix or null if there isn t one .<CODESPLIT>private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , secondBrace + 1 ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/Http403ForbiddenEntryPoint.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/Http403ForbiddenEntryPoint.java<CODESPLIT>Always returns a 403 error code to the client .<CODESPLIT>public void commence ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/http/DefaultFilterChainValidator.java<CODESPLIT>config/src/main/java/org/springframework/security/config/http/DefaultFilterChainValidator.java<CODESPLIT>Checks the filter list for possible errors and logs them<CODESPLIT>private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/ThrowableAnalyzer.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/ThrowableAnalyzer.java<CODESPLIT>Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/ThrowableAnalyzer.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/ThrowableAnalyzer.java<CODESPLIT>Extracts the cause of the given throwable using an appropriate extractor .<CODESPLIT>private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/method/GlobalMethodSecurityBeanDefinitionParser.java<CODESPLIT>config/src/main/java/org/springframework/security/config/method/GlobalMethodSecurityBeanDefinitionParser.java<CODESPLIT>Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .<CODESPLIT>@ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/AuthorityUtils.java<CODESPLIT>core/src/main/java/org/springframework/security/core/authority/AuthorityUtils.java<CODESPLIT>Converts an array of GrantedAuthority objects to a Set .<CODESPLIT>public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/StandardPasswordEncoder.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/password/StandardPasswordEncoder.java<CODESPLIT>Constant time comparison to prevent against timing attacks .<CODESPLIT>private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return false ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/SimpleUrlAuthenticationFailureHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/SimpleUrlAuthenticationFailureHandler.java<CODESPLIT>The URL which will be used as the failure destination .<CODESPLIT>public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/ui/DefaultLogoutPageGeneratingFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/ui/DefaultLogoutPageGeneratingFilter.java<CODESPLIT>Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .<CODESPLIT>public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/UrlUtils.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/UrlUtils.java<CODESPLIT>Obtains the web application - specific fragment of the URL .<CODESPLIT>private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/util/UrlUtils.java<CODESPLIT>web/src/main/java/org/springframework/security/web/util/UrlUtils.java<CODESPLIT>Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .<CODESPLIT>public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return false ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
1<CODESPLIT>openid/src/main/java/org/springframework/security/openid/RegexBasedAxFetchListFactory.java<CODESPLIT>openid/src/main/java/org/springframework/security/openid/RegexBasedAxFetchListFactory.java<CODESPLIT>Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .<CODESPLIT>public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
1<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/AclClassIdUtils.java<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/AclClassIdUtils.java<CODESPLIT>Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .<CODESPLIT>Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else { // Assume it should be a Long type identifier = convertToLong ( identifier ) ; } return identifier ; }
1<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .<CODESPLIT>protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , true ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
1<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .<CODESPLIT>protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , true ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , true , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
1<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>acl/src/main/java/org/springframework/security/acls/jdbc/JdbcMutableAclService.java<CODESPLIT>Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .<CODESPLIT>protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , true ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/HttpSessionRequestCache.java<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/HttpSessionRequestCache.java<CODESPLIT>Stores the current request provided the configuration properties allow it .<CODESPLIT>public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( false ) != null ) { // Store the HTTP request itself. Used by // AbstractAuthenticationProcessingFilter // for redirection after successful authentication (SEC-29) request . getSession ( ) . setAttribute ( this . sessionAttrName , savedRequest ) ; logger . debug ( "DefaultSavedRequest added to Session: " + savedRequest ) ; } } else { logger . debug ( "Request not saved as configured RequestMatcher did not match" ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java<CODESPLIT>web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java<CODESPLIT>Creates a matcher that matches on the specific method and any of the provided patterns .<CODESPLIT>public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java<CODESPLIT>web/src/main/java/org/springframework/security/web/server/util/matcher/ServerWebExchangeMatchers.java<CODESPLIT>Matches any exchange<CODESPLIT>public static ServerWebExchangeMatcher anyExchange ( ) { // we don't use a lambda to ensure a unique equals and hashcode // which otherwise can cause problems with adding multiple entries to an ordered LinkedHashMap return new ServerWebExchangeMatcher ( ) { @ Override public Mono < MatchResult > matches ( ServerWebExchange exchange ) { return ServerWebExchangeMatcher . MatchResult . match ( ) ; } } ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .<CODESPLIT>public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .<CODESPLIT>public static TextEncryptor text ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
1<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>crypto/src/main/java/org/springframework/security/crypto/encrypt/Encryptors.java<CODESPLIT>Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .<CODESPLIT>public static TextEncryptor queryableText ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/header/writers/frameoptions/XFrameOptionsHeaderWriter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/header/writers/frameoptions/XFrameOptionsHeaderWriter.java<CODESPLIT>Writes the X - Frame - Options header value overwritting any previous value .<CODESPLIT>public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>Builds the target URL according to the logic defined in the main class Javadoc<CODESPLIT>protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>Builds the target URL according to the logic defined in the main class Javadoc .<CODESPLIT>protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; } // Check for the parameter and use that if available String targetUrl = null ; if ( targetUrlParameter != null ) { targetUrl = request . getParameter ( targetUrlParameter ) ; if ( StringUtils . hasText ( targetUrl ) ) { logger . debug ( "Found targetUrlParameter in request: " + targetUrl ) ; return targetUrl ; } } if ( useReferer && ! StringUtils . hasLength ( targetUrl ) ) { targetUrl = request . getHeader ( "Referer" ) ; logger . debug ( "Using Referer header: " + targetUrl ) ; } if ( ! StringUtils . hasText ( targetUrl ) ) { targetUrl = defaultTargetUrl ; logger . debug ( "Using default Url: " + targetUrl ) ; } return targetUrl ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/AbstractAuthenticationTargetUrlRequestHandler.java<CODESPLIT>If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .<CODESPLIT>public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
1<CODESPLIT>samples/xml/dms/src/main/java/sample/dms/DocumentDaoImpl.java<CODESPLIT>samples/xml/dms/src/main/java/sample/dms/DocumentDaoImpl.java<CODESPLIT>Executes recursive SQL as needed to build a full Directory hierarchy of objects<CODESPLIT>private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) { // Need to go and lookup the parent, so do that first parentDirectory = getDirectoryWithImmediateParentPopulated ( parentDirectoryId ) ; } Directory directory = new Directory ( rs . getString ( "directory_name" ) , parentDirectory ) ; FieldUtils . setProtectedFieldValue ( "id" , directory , new Long ( rs . getLong ( "id" ) ) ) ; return directory ; } } ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/DefaultLdapUsernameToDnMapper.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/DefaultLdapUsernameToDnMapper.java<CODESPLIT>Assembles the Distinguished Name that should be used the given username .<CODESPLIT>public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
1<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.java<CODESPLIT>config/src/main/java/org/springframework/security/config/annotation/web/configuration/WebSecurityConfigurerAdapter.java<CODESPLIT>Creates the shared objects<CODESPLIT>private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/authentication/jaas/JaasAuthenticationProvider.java<CODESPLIT>core/src/main/java/org/springframework/security/authentication/jaas/JaasAuthenticationProvider.java<CODESPLIT>Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .<CODESPLIT>private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = false ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>Gets the current date in HTTP format .<CODESPLIT>public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>Parses date with given formatters .<CODESPLIT>private static Long internalParseDate ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>web/src/main/java/org/springframework/security/web/savedrequest/FastHttpDateFormat.java<CODESPLIT>Updates cache .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , value ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/UsernamePasswordAuthenticationFilter.java<CODESPLIT>Provided so that subclasses may configure what is put into the authentication request s details property .<CODESPLIT>protected void setDetails ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/DefaultWASUsernameAndGroupsExtractor.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/DefaultWASUsernameAndGroupsExtractor.java<CODESPLIT>Get the security name for the given subject .<CODESPLIT>private static String getSecurityName ( final Subject subject ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + subject ) ; } String userSecurityName = null ; if ( subject != null ) { // SEC-803 Object credential = subject . getPublicCredentials ( getWSCredentialClass ( ) ) . iterator ( ) . next ( ) ; if ( credential != null ) { userSecurityName = ( String ) invokeMethod ( getSecurityNameMethod ( ) , credential ) ; } } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Websphere security name is " + userSecurityName + " for subject " + subject ) ; } return userSecurityName ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/DefaultWASUsernameAndGroupsExtractor.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/preauth/websphere/DefaultWASUsernameAndGroupsExtractor.java<CODESPLIT>Get the WebSphere group names for the given security name .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try { // TODO: Cache UserRegistry object ic = new InitialContext ( ) ; Object objRef = ic . lookup ( USER_REGISTRY ) ; Object userReg = invokeMethod ( getNarrowMethod ( ) , null , objRef , Class . forName ( "com.ibm.websphere.security.UserRegistry" ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining WebSphere groups for user " + securityName + " using WebSphere UserRegistry " + userReg ) ; } final Collection groups = ( Collection ) invokeMethod ( getGroupsForUserMethod ( ) , userReg , new Object [ ] { securityName } ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Groups for user " + securityName + ": " + groups . toString ( ) ) ; } return new ArrayList ( groups ) ; } catch ( Exception e ) { logger . error ( "Exception occured while looking up groups for user" , e ) ; throw new RuntimeException ( "Exception occured while looking up groups for user" , e ) ; } finally { try { if ( ic != null ) { ic . close ( ) ; } } catch ( NamingException e ) { logger . debug ( "Exception occured while closing context" , e ) ; } } }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsManager.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsManager.java<CODESPLIT>Changes the password for the current user . The username is obtained from the security context .<CODESPLIT>public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsManager.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/userdetails/LdapUserDetailsManager.java<CODESPLIT>Creates a DN from a group name .<CODESPLIT>protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/session/ConcurrentSessionControlAuthenticationStrategy.java<CODESPLIT>web/src/main/java/org/springframework/security/web/authentication/session/ConcurrentSessionControlAuthenticationStrategy.java<CODESPLIT>Allows subclasses to customise behaviour when too many sessions are detected .<CODESPLIT>protected void allowableSessionsExceeded ( List < SessionInformation > sessions , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; } // Determine least recently used session, and mark it for invalidation SessionInformation leastRecentlyUsed = null ; for ( SessionInformation session : sessions ) { if ( ( leastRecentlyUsed == null ) || session . getLastRequest ( ) . before ( leastRecentlyUsed . getLastRequest ( ) ) ) { leastRecentlyUsed = session ; } } leastRecentlyUsed . expireNow ( ) ; }
1<CODESPLIT>core/src/main/java/org/springframework/security/authentication/ProviderManager.java<CODESPLIT>core/src/main/java/org/springframework/security/authentication/ProviderManager.java<CODESPLIT>Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .<CODESPLIT>private void copyDetails ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/FilterChainProxy.java<CODESPLIT>web/src/main/java/org/springframework/security/web/FilterChainProxy.java<CODESPLIT>Returns the first filter chain matching the supplied URL .<CODESPLIT>private List < Filter > getFilters ( HttpServletRequest request ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( request ) ) { return chain . getFilters ( ) ; } } return null ; }
1<CODESPLIT>web/src/main/java/org/springframework/security/web/FilterChainProxy.java<CODESPLIT>web/src/main/java/org/springframework/security/web/FilterChainProxy.java<CODESPLIT>Convenience method mainly for testing .<CODESPLIT>public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
1<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AccessControlListTag.java<CODESPLIT>taglibs/src/main/java/org/springframework/security/taglibs/authz/AccessControlListTag.java<CODESPLIT>Allows test cases to override where application context obtained from .<CODESPLIT>protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
1<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/LdapUtils.java<CODESPLIT>ldap/src/main/java/org/springframework/security/ldap/LdapUtils.java<CODESPLIT>Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .<CODESPLIT>public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/internal/MockMvcRequestSpecificationImpl.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/internal/MockMvcRequestSpecificationImpl.java<CODESPLIT>Set session attributes .<CODESPLIT>public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/authentication/PreemptiveAuthProvider.java<CODESPLIT>rest-assured/src/main/java/io/restassured/authentication/PreemptiveAuthProvider.java<CODESPLIT>Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .<CODESPLIT>public AuthenticationScheme basic ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Add default filters that will be applied to each request .<CODESPLIT>public static void filters ( List < Filter > filters ) { Validate . notNull ( filters , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( filters ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Add default filters to apply to each request .<CODESPLIT>public static void filters ( Filter filter , Filter ... additionalFilters ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Create a http basic authentication scheme .<CODESPLIT>public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; return scheme ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Create a NTLM authentication scheme .<CODESPLIT>public static AuthenticationScheme ntlm ( String userName , String password , String workstation , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( workstation ) ; scheme . setDomain ( domain ) ; return scheme ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Use form authentication with the supplied configuration .<CODESPLIT>public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>rest-assured/src/main/java/io/restassured/RestAssured.java<CODESPLIT>Instruct REST Assured to connect to a proxy using a URI .<CODESPLIT>public static void proxy ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } proxy ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/print/ResponsePrinter.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/print/ResponsePrinter.java<CODESPLIT>Prints the response to the print stream<CODESPLIT>public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/RestAssuredConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/RestAssuredConfig.java<CODESPLIT>Set the redirect config .<CODESPLIT>public RestAssuredConfig redirect ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/EncoderConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/EncoderConfig.java<CODESPLIT>Specify the default charset for query parameters<CODESPLIT>public EncoderConfig defaultQueryParameterCharset ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/ObjectMapperConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/ObjectMapperConfig.java<CODESPLIT>Creates an object mapper configuration that uses the specified object mapper as default .<CODESPLIT>public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/ObjectMapperConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/ObjectMapperConfig.java<CODESPLIT>Specify a custom JAXB object mapper factory .<CODESPLIT>public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , true ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the Log config .<CODESPLIT>public RestAssuredMockMvcConfig logConfig ( LogConfig logConfig ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the session config .<CODESPLIT>public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the object mapper config .<CODESPLIT>public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the Json config .<CODESPLIT>public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the Xml config .<CODESPLIT>public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the encoder config<CODESPLIT>public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the header config<CODESPLIT>public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the async config<CODESPLIT>public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the MockMVC config<CODESPLIT>public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the multi - part config<CODESPLIT>public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the parameter config<CODESPLIT>public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/RestAssuredMockMvcConfig.java<CODESPLIT>Set the matcher config<CODESPLIT>public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/authentication/CertificateAuthSettings.java<CODESPLIT>rest-assured/src/main/java/io/restassured/authentication/CertificateAuthSettings.java<CODESPLIT>Configure the CertificateAuthSettings to allow all host names .<CODESPLIT>public CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
1<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/config/XmlPathConfig.java<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/config/XmlPathConfig.java<CODESPLIT>Specify declared namespaces that will be used when parsing XML .<CODESPLIT>public XmlPathConfig declareNamespaces ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
1<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/config/XmlPathConfig.java<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/config/XmlPathConfig.java<CODESPLIT>Declares a namespace .<CODESPLIT>public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , true , allowDocTypeDeclaration ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>Make an HTTP request to the default URI and parse using the default content - type .<CODESPLIT>public Object request ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .<CODESPLIT>public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HTTPBuilder.java<CODESPLIT>Set the default HTTP proxy to be used for all requests .<CODESPLIT>public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/MultiPartSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/MultiPartSpecBuilder.java<CODESPLIT>Specify the control name of this multi - part .<CODESPLIT>public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = true ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/MultiPartSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/MultiPartSpecBuilder.java<CODESPLIT>Add a header to this multipart specification .<CODESPLIT>public MultiPartSpecBuilder header ( String name , String value ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ; // Replace previous header if exists final Set < String > headerNames = headers . keySet ( ) ; final String trimmedName = name . trim ( ) ; for ( String headerName : headerNames ) { if ( headerName . equalsIgnoreCase ( trimmedName ) ) { headers . remove ( headerName ) ; } } // Put the name header in the header list headers . put ( name , value ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/AuthConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/AuthConfig.java<CODESPLIT>Set authentication credentials to be used for the given host and port .<CODESPLIT>public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/AuthConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/AuthConfig.java<CODESPLIT>Set NTLM authentication credentials to be used for the given host and port .<CODESPLIT>public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/http/Headers.java<CODESPLIT>rest-assured/src/main/java/io/restassured/http/Headers.java<CODESPLIT>An alternative way to create a Headers object from the constructor .<CODESPLIT>public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/RestAssuredMockMvc.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/RestAssuredMockMvc.java<CODESPLIT>Reset all static configurations to their default values .<CODESPLIT>public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseBuilder.java<CODESPLIT>Set a specific header<CODESPLIT>public ResponseBuilder setHeader ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseBuilder.java<CODESPLIT>Build the actual response<CODESPLIT>public Response build ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether value of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher value ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether comment of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether expiry date of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether domain of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether path of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether secured property of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether http - only property of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether version of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>rest-assured/src/main/java/io/restassured/matcher/DetailedCookieMatcher.java<CODESPLIT>Verifies whether max age of cookie satisfies specified matcher .<CODESPLIT>public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>Expect that a response header matches the supplied header name and hamcrest matcher .<CODESPLIT>public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>Expect that a response header matches the supplied name and value .<CODESPLIT>public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/ResponseSpecBuilder.java<CODESPLIT>Expect that a response cookie matches the supplied name and value .<CODESPLIT>public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/specification/ProxySpecification.java<CODESPLIT>rest-assured/src/main/java/io/restassured/specification/ProxySpecification.java<CODESPLIT>Specify the hostname of the proxy .<CODESPLIT>public ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/config/JsonPathConfig.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/config/JsonPathConfig.java<CODESPLIT>Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .<CODESPLIT>public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/config/JsonPathConfig.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/config/JsonPathConfig.java<CODESPLIT>Creates an json path configuration that uses the specified parser type as default .<CODESPLIT>public JsonPathConfig defaultParserType ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/LogConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/LogConfig.java<CODESPLIT>Specify a new default stream to the print to .<CODESPLIT>public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , true , logDetailIfValidationFails , urlEncodeRequestUri , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/LogConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/LogConfig.java<CODESPLIT>Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail<CODESPLIT>public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HttpRequestFactory.java<CODESPLIT>rest-assured/src/main/java/io/restassured/internal/http/HttpRequestFactory.java<CODESPLIT>Get the HttpRequest class that represents this request type .<CODESPLIT>static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ; // If we are sending HTTP method that does not allow body (like GET) then HTTP library prevents // us from including it, however we chose to allow deviations from standard if user wants so, // so it needs custom handling - hence the second condition below. // Otherwise we should use standard implementation found in the map if ( type == null || ( ! ( type . isInstance ( HttpEntityEnclosingRequest . class ) ) && hasBody ) ) { httpRequest = new CustomHttpMethod ( method , uri ) ; } else { try { httpRequest = type . newInstance ( ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } httpRequest . setURI ( uri ) ; } return httpRequest ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/MultiPartConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/MultiPartConfig.java<CODESPLIT>Specify an explicit default multipart boundary to use when sending multi - part data .<CODESPLIT>public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , true ) ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>Add request attribute<CODESPLIT>public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>Add a header to be sent with the request<CODESPLIT>public MockMvcRequestSpecBuilder addHeader ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>Specify a string to send to the server using multi - part form data with a specific mime - type .<CODESPLIT>public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/specification/MockMvcRequestSpecBuilder.java<CODESPLIT>Add a result handler<CODESPLIT>public MockMvcRequestSpecBuilder addResultHandlers ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>Set a http client parameter .<CODESPLIT>public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>Add the given parameters to an already configured number of parameters .<CODESPLIT>public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .<CODESPLIT>public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>rest-assured/src/main/java/io/restassured/config/HttpClientConfig.java<CODESPLIT>Specify the HTTP Multipart mode when sending multi - part data .<CODESPLIT>public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , true ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a boolean .<CODESPLIT>public < T > T get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) jsonAssertion . getResult ( json , null ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as an int .<CODESPLIT>public int getInt ( String path ) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get ( path ) ; if ( value instanceof Integer ) { return ( Integer ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . intValue ( ) ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . intValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Integer . class ) ; } }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a byte .<CODESPLIT>public byte getByte ( String path ) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get ( path ) ; if ( value instanceof Byte ) { return ( Byte ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . byteValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . byteValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Byte . class ) ; } }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a short .<CODESPLIT>public short getShort ( String path ) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get ( path ) ; if ( value instanceof Short ) { return ( Short ) value ; } else if ( value instanceof Long ) { return ( ( Long ) value ) . shortValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . shortValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Short . class ) ; } }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a float .<CODESPLIT>public float getFloat ( String path ) { final Object value = get ( path ) ; //Groovy will always return a Double for floating point values. if ( value instanceof Double ) { return ( ( Double ) value ) . floatValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Float . class ) ; } }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a double .<CODESPLIT>public double getDouble ( String path ) { final Object value = get ( path ) ; if ( value instanceof Double ) { return ( Double ) value ; } return ObjectConverter . convertObjectTo ( value , Double . class ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a long .<CODESPLIT>public long getLong ( String path ) { //The type returned from Groovy depends on the input, so we need to handle different numerical types. Object value = get ( path ) ; if ( value instanceof Long ) { return ( Long ) value ; } else if ( value instanceof Short ) { return ( ( Short ) value ) . longValue ( ) ; } else if ( value instanceof Integer ) { return ( ( Integer ) value ) . longValue ( ) ; } else { return ObjectConverter . convertObjectTo ( value , Long . class ) ; } }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a list .<CODESPLIT>public < T > List < T > getList ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) { // TODO Avoid double parsing String str = objectToString ( t ) ; //noinspection unchecked e = ( T ) jsonStringToObject ( str , genericType ) ; } else { e = ObjectConverter . convertObjectTo ( t , genericType ) ; } newList . add ( e ) ; } } return Collections . unmodifiableList ( newList ) ; }
1<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>json-path/src/main/java/io/restassured/path/json/JsonPath.java<CODESPLIT>Get the result of an Object path expression as a map .<CODESPLIT>public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
1<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/XmlPath.java<CODESPLIT>xml-path/src/main/java/io/restassured/path/xml/XmlPath.java<CODESPLIT>Get an XML document as a Java Object .<CODESPLIT>public < T > T getObject ( String path , Class < T > objectType ) { Object object = getFromPath ( path , false ) ; return getObjectAsType ( object , objectType ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .<CODESPLIT>public RequestSpecBuilder setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>Add a cookie to be sent with the request .<CODESPLIT>public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>Add a parameter to be sent with the request .<CODESPLIT>public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>rest-assured/src/main/java/io/restassured/builder/RequestSpecBuilder.java<CODESPLIT>Add a multi - value parameter to be sent with the request .<CODESPLIT>public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
1<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/MockMvcParamConfig.java<CODESPLIT>modules/spring-mock-mvc/src/main/java/io/restassured/module/mockmvc/config/MockMvcParamConfig.java<CODESPLIT>Set form parameter update strategy to the given value .<CODESPLIT>public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , true ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/filter/log/ResponseLoggingFilter.java<CODESPLIT>rest-assured/src/main/java/io/restassured/filter/log/ResponseLoggingFilter.java<CODESPLIT>Create a new logging filter without using the new operator . Will make the DSL look nicer .<CODESPLIT>public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }
1<CODESPLIT>rest-assured/src/main/java/io/restassured/http/Cookies.java<CODESPLIT>rest-assured/src/main/java/io/restassured/http/Cookies.java<CODESPLIT>An alternative way to create a Cookies object from the constructor .<CODESPLIT>public static Cookies cookies ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/WeakKeySet.java<CODESPLIT>core/src/com/google/inject/internal/WeakKeySet.java<CODESPLIT>There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .<CODESPLIT>private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Indexes bindings by type .<CODESPLIT>void index ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Gets a binding implementation . First it check to see if the parent has a binding . If the parent has a binding and the binding is scoped it will use that binding . Otherwise this checks for an explicit binding . If no explicit binding is found it looks for a just - in - time binding .<CODESPLIT>< T > BindingImpl < T > getBindingOrThrow ( Key < T > key , Errors errors , JitLimitation jitType ) throws ErrorsException { // Check explicit bindings, i.e. bindings created by modules. BindingImpl < T > binding = state . getExplicitBinding ( key ) ; if ( binding != null ) { return binding ; } // Look for an on-demand binding. return getJustInTimeBinding ( key , errors , jitType ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Converts a constant string binding to the required type .<CODESPLIT>private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException { // Find a constant string binding. Key < String > stringKey = key . ofType ( STRING_TYPE ) ; BindingImpl < String > stringBinding = state . getExplicitBinding ( stringKey ) ; if ( stringBinding == null || ! stringBinding . isConstant ( ) ) { return null ; } // We can't call getProvider().get() because this InstanceBinding may not have been inintialized // yet (because we may have been called during InternalInjectorCreator.initializeStatically and // instance binding validation hasn't happened yet.) @ SuppressWarnings ( "unchecked" ) String stringValue = ( ( InstanceBinding < String > ) stringBinding ) . getInstance ( ) ; Object source = stringBinding . getSource ( ) ; // Find a matching type converter. TypeLiteral < T > type = key . getTypeLiteral ( ) ; TypeConverterBinding typeConverterBinding = state . getConverter ( stringValue , type , errors , source ) ; if ( typeConverterBinding == null ) { // No converter can handle the given type. return null ; } // Try to convert the string. A failed conversion results in an error. try { @ SuppressWarnings ( "unchecked" ) // This cast is safe because we double check below. T converted = ( T ) typeConverterBinding . getTypeConverter ( ) . convert ( stringValue , type ) ; if ( converted == null ) { throw errors . converterReturnedNull ( stringValue , source , type , typeConverterBinding ) . toException ( ) ; } if ( ! type . getRawType ( ) . isInstance ( converted ) ) { throw errors . conversionTypeError ( stringValue , source , type , typeConverterBinding , converted ) . toException ( ) ; } return new ConvertedConstantBindingImpl < T > ( this , key , converted , stringBinding , typeConverterBinding ) ; } catch ( ErrorsException e ) { throw e ; } catch ( RuntimeException e ) { throw errors . conversionError ( stringValue , source , type , typeConverterBinding , e ) . toException ( ) ; } }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .<CODESPLIT>private boolean cleanup ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = false ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) { // only check if we haven't looked at this key yet BindingImpl depBinding = jitBindings . get ( depKey ) ; if ( depBinding != null ) { // if the binding still exists, validate boolean failed = cleanup ( depBinding , encountered ) ; // if children fail, we fail if ( depBinding instanceof ConstructorBindingImpl ) { ConstructorBindingImpl ctorBinding = ( ConstructorBindingImpl ) depBinding ; ip = ctorBinding . getInternalConstructor ( ) ; if ( ! ctorBinding . isInitialized ( ) ) { failed = true ; } } if ( failed ) { removeFailedJitBinding ( depBinding , ip ) ; bindingFailed = true ; } } else if ( state . getExplicitBinding ( depKey ) == null ) { // ignore keys if they were explicitly bound, but if neither JIT // nor explicit, it's also invalid & should let parent know. bindingFailed = true ; } } } return bindingFailed ; }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Cleans up any state that may have been cached when constructing the JIT binding .<CODESPLIT>private void removeFailedJitBinding ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Safely gets the dependencies of possibly not initialized bindings .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>core/src/com/google/inject/internal/InjectorImpl.java<CODESPLIT>Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .<CODESPLIT>< T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ; // Don't try to inject arrays or enums annotated with @ImplementedBy. if ( rawType . isArray ( ) || ( rawType . isEnum ( ) && implementedBy != null ) ) { throw errors . missingImplementationWithHint ( key , this ) . toException ( ) ; } // Handle TypeLiteral<T> by binding the inner type if ( rawType == TypeLiteral . class ) { @ SuppressWarnings ( "unchecked" ) // we have to fudge the inner type as Object BindingImpl < T > binding = ( BindingImpl < T > ) createTypeLiteralBinding ( ( Key < TypeLiteral < Object > > ) key , errors ) ; return binding ; } // Handle @ImplementedBy if ( implementedBy != null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createImplementedByBinding ( key , scoping , implementedBy , errors ) ; } // Handle @ProvidedBy. ProvidedBy providedBy = rawType . getAnnotation ( ProvidedBy . class ) ; if ( providedBy != null ) { Annotations . checkForMisplacedScopeAnnotations ( rawType , source , errors ) ; return createProvidedByBinding ( key , scoping , providedBy , errors ) ; } return ConstructorBindingImpl . create ( this , key , null , /* use default constructor */ source , scoping , errors , jitBinding && options . jitDisabled , options . atInjectRequired ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/SingleParameterInjector.java<CODESPLIT>core/src/com/google/inject/internal/SingleParameterInjector.java<CODESPLIT>Returns an array of parameter values .<CODESPLIT>static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ; // optimization: use manual for/each to save allocating an iterator here for ( int i = 0 ; i < size ; i ++ ) { parameters [ i ] = parameterInjectors [ i ] . inject ( context ) ; } return parameters ; }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorShell.java<CODESPLIT>core/src/com/google/inject/internal/InjectorShell.java<CODESPLIT>The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .<CODESPLIT>private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/InjectorShell.java<CODESPLIT>core/src/com/google/inject/internal/InjectorShell.java<CODESPLIT>The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .<CODESPLIT>private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
1<CODESPLIT>core/src/com/google/inject/spi/InjectionPoint.java<CODESPLIT>core/src/com/google/inject/spi/InjectionPoint.java<CODESPLIT>Returns true if the binding annotation is in the wrong place .<CODESPLIT>private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return false ; } // don't warn about misplaced binding annotations on methods when there's a field with the same // name. In Scala, fields always get accessor methods (that we need to ignore). See bug 242. if ( member instanceof Method ) { try { if ( member . getDeclaringClass ( ) . getDeclaredField ( member . getName ( ) ) != null ) { return false ; } } catch ( NoSuchFieldException ignore ) { } } errors . misplacedBindingAnnotation ( member , misplacedBindingAnnotation ) ; return true ; }
1<CODESPLIT>core/src/com/google/inject/spi/InjectionPoint.java<CODESPLIT>core/src/com/google/inject/spi/InjectionPoint.java<CODESPLIT>Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .<CODESPLIT>private static boolean overrides ( Method a , Method b ) { // See JLS section 8.4.8.1 int modifiers = b . getModifiers ( ) ; if ( Modifier . isPublic ( modifiers ) || Modifier . isProtected ( modifiers ) ) { return true ; } if ( Modifier . isPrivate ( modifiers ) ) { return false ; } // b must be package-private return a . getDeclaringClass ( ) . getPackage ( ) . equals ( b . getDeclaringClass ( ) . getPackage ( ) ) ; }
1<CODESPLIT>core/src/com/google/inject/spi/MembersInjectorLookup.java<CODESPLIT>core/src/com/google/inject/spi/MembersInjectorLookup.java<CODESPLIT>Sets the actual members injector .<CODESPLIT>public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
1<CODESPLIT>core/src/com/google/inject/TypeLiteral.java<CODESPLIT>core/src/com/google/inject/TypeLiteral.java<CODESPLIT>Gets the type of this type s provider .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) { // This cast is safe and wouldn't generate a warning if Type had a type // parameter. return ( TypeLiteral < Provider < T > > ) get ( Types . providerOf ( getType ( ) ) ) ; }
1<CODESPLIT>core/src/com/google/inject/TypeLiteral.java<CODESPLIT>core/src/com/google/inject/TypeLiteral.java<CODESPLIT>Returns an immutable list of the resolved types .<CODESPLIT>private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { result [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/MoreTypes.java<CODESPLIT>core/src/com/google/inject/internal/MoreTypes.java<CODESPLIT>Returns an type that s appropriate for use in a key .<CODESPLIT>public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ; // the following casts are generally unsafe, but com.google.inject.Provider extends // javax.inject.Provider and is covariant @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > guiceProviderType = ( TypeLiteral < T > ) TypeLiteral . get ( Types . providerOf ( parameterizedType . getActualTypeArguments ( ) [ 0 ] ) ) ; return guiceProviderType ; } @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > wrappedPrimitives = ( TypeLiteral < T > ) PRIMITIVE_TO_WRAPPER . get ( typeLiteral ) ; if ( wrappedPrimitives != null ) { return wrappedPrimitives ; } // If we know this isn't a subclass, return as-is. if ( typeLiteral . getClass ( ) == TypeLiteral . class ) { return typeLiteral ; } // recreate the TypeLiteral to avoid anonymous TypeLiterals from holding refs to their // surrounding classes. @ SuppressWarnings ( "unchecked" ) TypeLiteral < T > recreated = ( TypeLiteral < T > ) TypeLiteral . get ( typeLiteral . getType ( ) ) ; return recreated ; }
1<CODESPLIT>core/src/com/google/inject/internal/TypeConverterBindingProcessor.java<CODESPLIT>core/src/com/google/inject/internal/TypeConverterBindingProcessor.java<CODESPLIT>Installs default converters for primitives enums and class literals .<CODESPLIT>static void prepareBuiltInConverters ( InjectorImpl injector ) { // Configure type converters. convertToPrimitiveType ( injector , int . class , Integer . class ) ; convertToPrimitiveType ( injector , long . class , Long . class ) ; convertToPrimitiveType ( injector , boolean . class , Boolean . class ) ; convertToPrimitiveType ( injector , byte . class , Byte . class ) ; convertToPrimitiveType ( injector , short . class , Short . class ) ; convertToPrimitiveType ( injector , float . class , Float . class ) ; convertToPrimitiveType ( injector , double . class , Double . class ) ; convertToClass ( injector , Character . class , new TypeConverter ( ) { @ Override public Object convert ( String value , TypeLiteral < ? > toType ) { value = value . trim ( ) ; if ( value . length ( ) != 1 ) { throw new RuntimeException ( "Length != 1." ) ; } return value . charAt ( 0 ) ; } @ Override public String toString ( ) { return "TypeConverter<Character>" ; } } ) ; convertToClasses ( injector , Matchers . subclassesOf ( Enum . class ) , new TypeConverter ( ) { @ Override @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { return Enum . valueOf ( ( Class ) toType . getRawType ( ) , value ) ; } @ Override public String toString ( ) { return "TypeConverter<E extends Enum<E>>" ; } } ) ; internalConvertToTypes ( injector , new AbstractMatcher < TypeLiteral < ? > > ( ) { @ Override public boolean matches ( TypeLiteral < ? > typeLiteral ) { return typeLiteral . getRawType ( ) == Class . class ; } @ Override public String toString ( ) { return "Class<?>" ; } } , new TypeConverter ( ) { @ Override @ SuppressWarnings ( "unchecked" ) public Object convert ( String value , TypeLiteral < ? > toType ) { try { return Class . forName ( value ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e . getMessage ( ) ) ; } } @ Override public String toString ( ) { return "TypeConverter<Class<?>>" ; } } ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .<CODESPLIT>private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .<CODESPLIT>private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return false ; } }
1<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>core/src/com/google/inject/internal/BytecodeGen.java<CODESPLIT>Returns true if the member can be called by a fast class generated in a different classloader .<CODESPLIT>private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return false ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return false ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return false ; } } return true ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/Parameter.java<CODESPLIT>Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .<CODESPLIT>public Key < ? > fixAnnotations ( Key < ? > key ) { return key . getAnnotation ( ) == null ? key : Key . get ( key . getTypeLiteral ( ) , key . getAnnotation ( ) . annotationType ( ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Initializer.java<CODESPLIT>core/src/com/google/inject/internal/Initializer.java<CODESPLIT>Registers an instance for member injection when that step is performed .<CODESPLIT>< T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ; // short circuit if the object has no injections or listeners. if ( instance == null || ( injectionPoints . isEmpty ( ) && ! injector . membersInjectorStore . hasTypeListeners ( ) && provisionCallback == null ) ) { return Initializables . of ( instance ) ; } if ( initializablesCache . containsKey ( instance ) ) { @ SuppressWarnings ( "unchecked" ) // Map from T to InjectableReference<T> Initializable < T > cached = ( Initializable < T > ) initializablesCache . get ( instance ) ; return cached ; } InjectableReference < T > injectableReference = new InjectableReference < T > ( injector , instance , binding == null ? null : binding . getKey ( ) , provisionCallback , source , cycleDetectingLockFactory . create ( instance . getClass ( ) ) ) ; initializablesCache . put ( instance , injectableReference ) ; pendingInjections . add ( injectableReference ) ; return injectableReference ; }
1<CODESPLIT>core/src/com/google/inject/internal/Initializer.java<CODESPLIT>core/src/com/google/inject/internal/Initializer.java<CODESPLIT>Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .<CODESPLIT>void validateOustandingInjections ( Errors errors ) { validationStarted = true ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/AssistedConstructor.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/AssistedConstructor.java<CODESPLIT>Returns an instance of T constructed using this constructor with the supplied arguments .<CODESPLIT>public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( true ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ManagedFilterPipeline.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ManagedFilterPipeline.java<CODESPLIT>Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .<CODESPLIT>@ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) { // don't wrap the request if there are no servlets mapped. This prevents us from inserting our // wrapper unless it's actually going to be used. This is necessary for compatibility for apps // that downcast their HttpServletRequests to a concrete implementation. if ( ! servletPipeline . hasServletsMapped ( ) ) { return servletRequest ; } HttpServletRequest request = ( HttpServletRequest ) servletRequest ; //noinspection OverlyComplexAnonymousInnerClass return new HttpServletRequestWrapper ( request ) { @ Override public RequestDispatcher getRequestDispatcher ( String path ) { final RequestDispatcher dispatcher = servletPipeline . getRequestDispatcher ( path ) ; return ( null != dispatcher ) ? dispatcher : super . getRequestDispatcher ( path ) ; } } ; }
1<CODESPLIT>core/src/com/google/inject/internal/Scoping.java<CODESPLIT>core/src/com/google/inject/internal/Scoping.java<CODESPLIT>Scopes an internal factory .<CODESPLIT>static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ; // NOTE: SingletonScope relies on the fact that we are passing a // ProviderToInternalFactoryAdapter here.  If you change the type make sure to update // SingletonScope as well. Provider < T > scoped = scope . scope ( key , new ProviderToInternalFactoryAdapter < T > ( injector , creator ) ) ; return new InternalFactoryToProviderAdapter < T > ( scoped , source ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Scoping.java<CODESPLIT>core/src/com/google/inject/internal/Scoping.java<CODESPLIT>Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .<CODESPLIT>static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletUtils.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletUtils.java<CODESPLIT>Normalizes a path by unescaping all safe percent encoded characters .<CODESPLIT>static String normalizePath ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; } // Normalize the path.  we need to decode path segments, normalize and rejoin in order to // 1. decode and normalize safe percent escaped characters.  e.g. %70 -> 'p' // 2. decode and interpret dangerous character sequences. e.g. /%2E/ -> '/./' -> '/' // 3. preserve dangerous encoded characters. e.g. '/%2F/' -> '///' -> '/%2F' List < String > segments = new ArrayList <> ( ) ; for ( String segment : SLASH_SPLITTER . split ( path ) ) { // This decodes all non-special characters from the path segment.  so if someone passes // /%2E/foo we will normalize it to /./foo and then /foo String normalized = UrlEscapers . urlPathSegmentEscaper ( ) . escape ( lenientDecode ( segment , UTF_8 , false ) ) ; if ( "." . equals ( normalized ) ) { // skip } else if ( ".." . equals ( normalized ) ) { if ( segments . size ( ) > 1 ) { segments . remove ( segments . size ( ) - 1 ) ; } } else { segments . add ( normalized ) ; } } SLASH_JOINER . appendTo ( sb , segments ) ; if ( query != null ) { sb . append ( query ) ; } return sb . toString ( ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>Generates an Annotation for the annotation class . Requires that the annotation is all optionals .<CODESPLIT>public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>Returns true if the given annotation is retained at runtime .<CODESPLIT>public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
1<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>Returns the scoping annotation or null if there isn t one .<CODESPLIT>public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
1<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>Gets a key for the given type member and annotations .<CODESPLIT>public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>core/src/com/google/inject/internal/Annotations.java<CODESPLIT>Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .<CODESPLIT>public static String nameOf ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
1<CODESPLIT>core/src/com/google/inject/spi/ProviderLookup.java<CODESPLIT>core/src/com/google/inject/spi/ProviderLookup.java<CODESPLIT>Sets the actual provider .<CODESPLIT>public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/RealOptionalBinder.java<CODESPLIT>core/src/com/google/inject/internal/RealOptionalBinder.java<CODESPLIT>Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .<CODESPLIT>private void addDirectTypeBinding ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/ConstructorInjectorStore.java<CODESPLIT>core/src/com/google/inject/internal/ConstructorInjectorStore.java<CODESPLIT>Returns a new complete constructor injector with injection listeners registered .<CODESPLIT>public ConstructorInjector < ? > get ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
1<CODESPLIT>extensions/struts2/src/com/google/inject/struts2/Struts2Factory.java<CODESPLIT>extensions/struts2/src/com/google/inject/struts2/Struts2Factory.java<CODESPLIT>Returns true if the given class has a scope annotation .<CODESPLIT>private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return true ; } } return false ; }
1<CODESPLIT>core/src/com/google/inject/internal/RealMapBinder.java<CODESPLIT>core/src/com/google/inject/internal/RealMapBinder.java<CODESPLIT>since it s an easy way to group a type and an optional annotation type or instance .<CODESPLIT>static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/RealMapBinder.java<CODESPLIT>core/src/com/google/inject/internal/RealMapBinder.java<CODESPLIT>Adds a binding to the map for the given key .<CODESPLIT>Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
1<CODESPLIT>core/src/com/google/inject/internal/ConstructorInjector.java<CODESPLIT>core/src/com/google/inject/internal/ConstructorInjector.java<CODESPLIT>Provisions a new T .<CODESPLIT>private T provision ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; } // Store reference. If an injector re-enters this factory, they'll get the same reference. constructionContext . setCurrentReference ( t ) ; MembersInjectorImpl < T > localMembersInjector = membersInjector ; localMembersInjector . injectMembers ( t , context , false ) ; localMembersInjector . notifyListeners ( t ) ; return t ; } catch ( InvocationTargetException userException ) { Throwable cause = userException . getCause ( ) != null ? userException . getCause ( ) : userException ; throw InternalProvisionException . errorInjectingConstructor ( cause ) . addSource ( constructionProxy . getInjectionPoint ( ) ) ; } finally { constructionContext . removeCurrentReference ( ) ; } }
1<CODESPLIT>core/src/com/google/inject/spi/Message.java<CODESPLIT>core/src/com/google/inject/spi/Message.java<CODESPLIT>When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .<CODESPLIT>private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
1<CODESPLIT>extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethodsModule.java<CODESPLIT>extensions/throwingproviders/src/com/google/inject/throwingproviders/CheckedProviderMethodsModule.java<CODESPLIT>Returns a module which creates bindings for provider methods from the given module .<CODESPLIT>static Module forModule ( Module module ) { // avoid infinite recursion, since installing a module always installs itself if ( module instanceof CheckedProviderMethodsModule ) { return Modules . EMPTY_MODULE ; } return new CheckedProviderMethodsModule ( module ) ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>the collection is immutable .<CODESPLIT>@ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .<CODESPLIT>private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return false ; } }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Matching logic for constructors annotated with AssistedInject . This returns true if and only if all<CODESPLIT>private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; } // Require that every key exist in the constructor to match up exactly. for ( Key < ? > key : paramList ) { // If it didn't exist in the constructor set, we can't use it. if ( ! constructorKeys . remove ( key ) ) { return false ; } } // If any keys remain and their annotation is Assisted, we can't use it. for ( Key < ? > key : constructorKeys ) { if ( key . getAnnotationType ( ) == Assisted . class ) { return false ; } } // All @Assisted params match up to the method's parameters. return true ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Calculates all dependencies required by the implementation and constructor .<CODESPLIT>private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Return all non - assisted dependencies .<CODESPLIT>private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .<CODESPLIT>private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ; // optimization: create lazily for ( Dependency < ? > dep : dependencies ) { if ( isInjectorOrAssistedProvider ( dep ) ) { if ( badDeps == null ) { badDeps = Sets . newHashSet ( ) ; } badDeps . add ( dep ) ; } } if ( badDeps != null && ! badDeps . isEmpty ( ) ) { logger . log ( Level . WARNING , "AssistedInject factory {0} will be slow " + "because {1} has assisted Provider dependencies or injects the Injector. " + "Stop injecting @Assisted Provider<T> (instead use @Assisted T) " + "or Injector to speed things up. (It will be a ~6500% speed bump!)  " + "The exact offending deps are: {2}" , new Object [ ] { factoryType , implementation , badDeps } ) ; return false ; } return true ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>Creates a child injector that binds the args and returns the binding for the method s result .<CODESPLIT>public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ; // We ignore any pre-existing binding annotation. final Key < ? > returnKey = Key . get ( returnType . getTypeLiteral ( ) , RETURN_ANNOTATION ) ; Module assistedModule = new AbstractModule ( ) { @ Override @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) // raw keys are necessary for the args array and return value protected void configure ( ) { Binder binder = binder ( ) . withSource ( method ) ; int p = 0 ; if ( ! data . optimized ) { for ( Key < ? > paramKey : data . paramTypes ) { // Wrap in a Provider to cover null, and to prevent Guice from injecting the // parameter binder . bind ( ( Key ) paramKey ) . toProvider ( Providers . of ( args [ p ++ ] ) ) ; } } else { for ( Key < ? > paramKey : data . paramTypes ) { // Bind to our ThreadLocalProviders. binder . bind ( ( Key ) paramKey ) . toProvider ( data . providers . get ( p ++ ) ) ; } } Constructor constructor = data . constructor ; // Constructor *should* always be non-null here, // but if it isn't, we'll end up throwing a fairly good error // message for the user. if ( constructor != null ) { binder . bind ( returnKey ) . toConstructor ( constructor , ( TypeLiteral ) data . implementationType ) . in ( Scopes . NO_SCOPE ) ; // make sure we erase any scope on the implementation type } } } ; Injector forCreate = injector . createChildInjector ( assistedModule ) ; Binding < ? > binding = forCreate . getBinding ( returnKey ) ; // If we have providers cached in data, cache the binding for future optimizations. if ( data . optimized ) { data . cachedBinding = binding ; } return binding ; }
1<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>extensions/assistedinject/src/com/google/inject/assistedinject/FactoryProvider2.java<CODESPLIT>When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .<CODESPLIT>@ Override public Object invoke ( Object proxy , final Method method , final Object [ ] args ) throws Throwable { // If we setup a method handle earlier for this method, call it. // This is necessary for default methods that java8 creates, so we // can call the default method implementation (and not our proxied version of it). if ( methodHandleByMethod . containsKey ( method ) ) { return methodHandleByMethod . get ( method ) . invokeWithArguments ( args ) ; } if ( method . getDeclaringClass ( ) . equals ( Object . class ) ) { if ( "equals" . equals ( method . getName ( ) ) ) { return proxy == args [ 0 ] ; } else if ( "hashCode" . equals ( method . getName ( ) ) ) { return System . identityHashCode ( proxy ) ; } else { return method . invoke ( this , args ) ; } } AssistData data = assistDataByMethod . get ( method ) ; checkState ( data != null , "No data for method: %s" , method ) ; Provider < ? > provider ; if ( data . cachedBinding != null ) { // Try to get optimized form... provider = data . cachedBinding . getProvider ( ) ; } else { provider = getBindingFromNewInjector ( method , args , data ) . getProvider ( ) ; } try { int p = 0 ; for ( ThreadLocalProvider tlp : data . providers ) { tlp . set ( args [ p ++ ] ) ; } return provider . get ( ) ; } catch ( ProvisionException e ) { // if this is an exception declared by the factory method, throw it as-is if ( e . getErrorMessages ( ) . size ( ) == 1 ) { Message onlyError = getOnlyElement ( e . getErrorMessages ( ) ) ; Throwable cause = onlyError . getCause ( ) ; if ( cause != null && canRethrow ( method , cause ) ) { throw cause ; } } throw e ; } finally { for ( ThreadLocalProvider tlp : data . providers ) { tlp . remove ( ) ; } } }
1<CODESPLIT>core/src/com/google/inject/internal/Errors.java<CODESPLIT>core/src/com/google/inject/internal/Errors.java<CODESPLIT>Within guice s core allow for better missing binding messages<CODESPLIT>< T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ; // Keys which have similar strings as the desired key List < String > possibleMatches = new ArrayList <> ( ) ; // Check for other keys that may have the same type, // but not the same annotation TypeLiteral < T > type = key . getTypeLiteral ( ) ; List < Binding < T > > sameTypes = injector . findBindingsByType ( type ) ; if ( ! sameTypes . isEmpty ( ) ) { sb . append ( format ( "%n  Did you mean?" ) ) ; int howMany = Math . min ( sameTypes . size ( ) , MAX_MATCHING_TYPES_REPORTED ) ; for ( int i = 0 ; i < howMany ; ++ i ) { // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the given annotation vs actual annotation. sb . append ( format ( "%n    * %s" , sameTypes . get ( i ) . getKey ( ) ) ) ; } int remaining = sameTypes . size ( ) - MAX_MATCHING_TYPES_REPORTED ; if ( remaining > 0 ) { String plural = ( remaining == 1 ) ? "" : "s" ; sb . append ( format ( "%n    %d more binding%s with other annotations." , remaining , plural ) ) ; } } else { // For now, do a simple substring search for possibilities. This can help spot // issues when there are generics being used (such as a wrapper class) and the // user has forgotten they need to bind based on the wrapper, not the underlying // class. In the future, consider doing a strict in-depth type search. // TODO: Look into a better way to prioritize suggestions. For example, possbily // use levenshtein distance of the type literal strings. String want = type . toString ( ) ; Map < Key < ? > , Binding < ? > > bindingMap = injector . getAllBindings ( ) ; for ( Key < ? > bindingKey : bindingMap . keySet ( ) ) { String have = bindingKey . getTypeLiteral ( ) . toString ( ) ; if ( have . contains ( want ) || want . contains ( have ) ) { Formatter fmt = new Formatter ( ) ; Messages . formatSource ( fmt , bindingMap . get ( bindingKey ) . getSource ( ) ) ; String match = String . format ( "%s bound%s" , convert ( bindingKey ) , fmt . toString ( ) ) ; possibleMatches . add ( match ) ; // TODO: Consider a check that if there are more than some number of results, // don't suggest any. if ( possibleMatches . size ( ) > MAX_RELATED_TYPES_REPORTED ) { // Early exit if we have found more than we need. break ; } } } if ( ( possibleMatches . size ( ) > 0 ) && ( possibleMatches . size ( ) <= MAX_RELATED_TYPES_REPORTED ) ) { sb . append ( format ( "%n  Did you mean?" ) ) ; for ( String possibleMatch : possibleMatches ) { sb . append ( format ( "%n    %s" , possibleMatch ) ) ; } } } // If where are no possibilities to suggest, then handle the case of missing // annotations on simple types. This is usually a bad idea. if ( sameTypes . isEmpty ( ) && possibleMatches . isEmpty ( ) && key . getAnnotation ( ) == null && COMMON_AMBIGUOUS_TYPES . contains ( key . getTypeLiteral ( ) . getRawType ( ) ) ) { // We don't recommend using such simple types without annotations. sb . append ( format ( "%nThe key seems very generic, did you forget an annotation?" ) ) ; } return addMessage ( sb . toString ( ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/RealMultibinder.java<CODESPLIT>core/src/com/google/inject/internal/RealMultibinder.java<CODESPLIT>Implementation of newSetBinder .<CODESPLIT>public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > key ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , key ) ; binder . install ( result ) ; return result ; }
1<CODESPLIT>core/src/com/google/inject/internal/RealMultibinder.java<CODESPLIT>core/src/com/google/inject/internal/RealMultibinder.java<CODESPLIT>Adds a new entry to the set and returns the key for it .<CODESPLIT>Key < T > getKeyForNewItem ( ) { checkConfiguration ( ! bindingSelection . isInitialized ( ) , "Multibinder was already initialized" ) ; return Key . get ( bindingSelection . getElementTypeLiteral ( ) , new RealElement ( bindingSelection . getSetName ( ) , MULTIBINDER , "" ) ) ; }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/FilterChainInvocation.java<CODESPLIT>Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .<CODESPLIT>private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
1<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>Returns true if the inject annotation is on the constructor .<CODESPLIT>private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>Returns an injection point that can be used to clean up the constructor store .<CODESPLIT>InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
1<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>core/src/com/google/inject/internal/ConstructorBindingImpl.java<CODESPLIT>Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .<CODESPLIT>Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ; // If the below throws, it's OK -- we just ignore those dependencies, because no one // could have used them anyway. try { builder . addAll ( InjectionPoint . forInstanceMethodsAndFields ( constructorInjectionPoint . getDeclaringType ( ) ) ) ; } catch ( ConfigurationException ignored ) { } } else { builder . add ( getConstructor ( ) ) . addAll ( getInjectableMembers ( ) ) ; } return Dependency . forInjectionPoints ( builder . build ( ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/ProviderMethodsModule.java<CODESPLIT>core/src/com/google/inject/internal/ProviderMethodsModule.java<CODESPLIT>Returns a module which creates bindings methods in the module that match the scanner .<CODESPLIT>public static Module forModule ( Object module , ModuleAnnotatedMethodScanner scanner ) { return forObject ( module , false , scanner ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/ProviderMethodsModule.java<CODESPLIT>core/src/com/google/inject/internal/ProviderMethodsModule.java<CODESPLIT>Returns the annotation that is claimed by the scanner or null if there is none .<CODESPLIT>private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
1<CODESPLIT>core/src/com/google/inject/internal/util/LineNumbers.java<CODESPLIT>core/src/com/google/inject/internal/util/LineNumbers.java<CODESPLIT>Get the line number associated with the given member .<CODESPLIT>public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/DeferredLookups.java<CODESPLIT>core/src/com/google/inject/internal/DeferredLookups.java<CODESPLIT>Initialize the specified lookups either immediately or when the injector is created .<CODESPLIT>void initialize ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .<CODESPLIT>@ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .<CODESPLIT>public static < T > Callable < T > transferRequest ( Callable < T > callable ) { return wrap ( callable , transferRequest ( ) ) ; }
1<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>extensions/servlet/src/com/google/inject/servlet/ServletScopes.java<CODESPLIT>Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .<CODESPLIT>private static Object validateAndCanonicalizeValue ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
1<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>Returns a new complete members injector with injection listeners registered .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) // the MembersInjector type always agrees with the passed type public < T > MembersInjectorImpl < T > get ( TypeLiteral < T > key , Errors errors ) throws ErrorsException { return ( MembersInjectorImpl < T > ) cache . get ( key , errors ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>Creates a new members injector and attaches both injection listeners and method aspects .<CODESPLIT>private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>core/src/com/google/inject/internal/MembersInjectorStore.java<CODESPLIT>Returns the injectors for the specified injection points .<CODESPLIT>ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) { // ignored for now } } return ImmutableList . copyOf ( injectors ) ; }
1<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>Gets a key for an injection type and an annotation strategy .<CODESPLIT>static < T > Key < T > get ( Class < T > type , AnnotationStrategy annotationStrategy ) { return new Key < T > ( type , annotationStrategy ) ; }
1<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>Gets the strategy for an annotation .<CODESPLIT>static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
1<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>core/src/com/google/inject/Key.java<CODESPLIT>Gets the strategy for an annotation type .<CODESPLIT>static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/InterceptorStackCallback.java<CODESPLIT>core/src/com/google/inject/internal/InterceptorStackCallback.java<CODESPLIT>Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .<CODESPLIT>private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
1<CODESPLIT>core/src/com/google/inject/spi/DependencyAndSource.java<CODESPLIT>core/src/com/google/inject/spi/DependencyAndSource.java<CODESPLIT>Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .<CODESPLIT>public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
1<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>Returns the formatted message for an exception with the specified messages .<CODESPLIT>public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>Creates a new Message without a cause .<CODESPLIT>public static Message create ( String messageFormat , Object ... arguments ) { return create ( null , messageFormat , arguments ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>Creates a new Message with the given cause .<CODESPLIT>public static Message create ( Throwable cause , String messageFormat , Object ... arguments ) { return create ( cause , ImmutableList . of ( ) , messageFormat , arguments ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>Creates a new Message with the given cause and a binding source stack .<CODESPLIT>public static Message create ( Throwable cause , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , cause ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>core/src/com/google/inject/internal/Messages.java<CODESPLIT>Formats an object in a user friendly way .<CODESPLIT>static Object convert ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return convert ( o , source ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/util/SourceProvider.java<CODESPLIT>core/src/com/google/inject/internal/util/SourceProvider.java<CODESPLIT>Returns true if the className should be skipped .<CODESPLIT>private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/util/SourceProvider.java<CODESPLIT>core/src/com/google/inject/internal/util/SourceProvider.java<CODESPLIT>Returns the non - skipped module class name .<CODESPLIT>public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
1<CODESPLIT>extensions/jmx/src/com/google/inject/tools/jmx/Manager.java<CODESPLIT>extensions/jmx/src/com/google/inject/tools/jmx/Manager.java<CODESPLIT>Run with no arguments for usage instructions .<CODESPLIT>public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ; // Sleep forever. Thread . sleep ( Long . MAX_VALUE ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/InternalContext.java<CODESPLIT>core/src/com/google/inject/internal/InternalContext.java<CODESPLIT>Sets the new current dependency & adds it to the state .<CODESPLIT>Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
1<CODESPLIT>core/src/com/google/inject/internal/InternalContext.java<CODESPLIT>core/src/com/google/inject/internal/InternalContext.java<CODESPLIT>Adds to the state without setting the dependency .<CODESPLIT>void pushState ( com . google . inject . Key < ? > key , Object source ) { doPushState ( key , source ) ; }
1<CODESPLIT>core/src/com/google/inject/internal/Initializables.java<CODESPLIT>core/src/com/google/inject/internal/Initializables.java<CODESPLIT>Returns an initializable for an instance that requires no initialization .<CODESPLIT>static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
1<CODESPLIT>core/src/com/google/inject/internal/ProviderInternalFactory.java<CODESPLIT>core/src/com/google/inject/internal/ProviderInternalFactory.java<CODESPLIT>Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .<CODESPLIT>protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventListener.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventListener.java<CODESPLIT>Dispatch events .<CODESPLIT>public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventListener.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventListener.java<CODESPLIT>Add event processor .<CODESPLIT>public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/FutureTaskUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/FutureTaskUtil.java<CODESPLIT>get the result of a future task<CODESPLIT>public static < T > T getFutureTaskResult ( RunStateRecordedFutureTask < T > task , Logger logger ) { T t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/FutureTaskUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/FutureTaskUtil.java<CODESPLIT>launder the throwable<CODESPLIT>public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>Register processor to process command that has the command code of cmdCode .<CODESPLIT>public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>Register the default processor to process command with no specific processor registered .<CODESPLIT>public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>src/main/java/com/alipay/remoting/ProcessorManager.java<CODESPLIT>Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .<CODESPLIT>public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcAddressParser.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcAddressParser.java<CODESPLIT>try get from cache<CODESPLIT>private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/codec/ProtocolCodeBasedDecoder.java<CODESPLIT>src/main/java/com/alipay/remoting/codec/ProtocolCodeBasedDecoder.java<CODESPLIT>decode the protocol code<CODESPLIT>protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>Get all connections of all poolKey .<CODESPLIT>@ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>in case of cache pollution and connection leak to do schedule scan<CODESPLIT>@ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>If no task cached create one and initialize the connections .<CODESPLIT>@ Override public Connection getAndCreateIfAbsent ( Url url ) throws InterruptedException , RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { return pool . get ( ) ; } else { logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; return null ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .<CODESPLIT>@ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException { // get and create a connection pool with initialized connections. ConnectionPool pool = this . getConnectionPoolAndCreateIfAbsent ( url . getUniqueKey ( ) , new ConnectionPoolCall ( url ) ) ; if ( null != pool ) { healIfNeed ( pool , url ) ; } else { logger . error ( "[NOTIFYME] bug detected! pool here must not be null!" ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>remove task and remove all connections<CODESPLIT>private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>execute heal connection tasks if the actual number of connections in pool is less than expected<CODESPLIT>private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ; // only when async creating connections done // and the actual size of connections less than expected, the healing task can be run. if ( pool . isAsyncCreationDone ( ) && pool . size ( ) < url . getConnNum ( ) ) { FutureTask < Integer > task = this . healTasks . get ( poolKey ) ; if ( null == task ) { task = new FutureTask < Integer > ( new HealConnectionCall ( url , pool ) ) ; task = this . healTasks . putIfAbsent ( poolKey , task ) ; if ( null == task ) { task = this . healTasks . get ( poolKey ) ; task . run ( ) ; } } try { int numAfterHeal = task . get ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "[NOTIFYME] - conn num after heal {}, expected {}, warmup {}" , numAfterHeal , url . getConnNum ( ) , url . isConnWarmup ( ) ) ; } } catch ( InterruptedException e ) { this . healTasks . remove ( poolKey ) ; throw e ; } catch ( ExecutionException e ) { this . healTasks . remove ( poolKey ) ; Throwable cause = e . getCause ( ) ; if ( cause instanceof RemotingException ) { throw ( RemotingException ) cause ; } else { FutureTaskUtil . launderThrowable ( cause ) ; } } // heal task is one-off, remove from cache directly after run this . healTasks . remove ( poolKey ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionManager.java<CODESPLIT>do create connections<CODESPLIT>private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; } // create connection in sync way if ( syncCreateNumWhenNotWarmup > 0 ) { for ( int i = 0 ; i < syncCreateNumWhenNotWarmup ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } if ( syncCreateNumWhenNotWarmup == url . getConnNum ( ) ) { return ; } } // initialize executor in lazy way initializeExecutor ( ) ; pool . markAsyncCreationStart ( ) ; // mark the start of async try { this . asyncCreateConnectionExecutor . execute ( new Runnable ( ) { @ Override public void run ( ) { try { for ( int i = pool . size ( ) ; i < url . getConnNum ( ) ; ++ i ) { Connection conn = null ; try { conn = create ( url ) ; } catch ( RemotingException e ) { logger . error ( "Exception occurred in async create connection thread for {}, taskName {}" , url . getUniqueKey ( ) , taskName , e ) ; } pool . add ( conn ) ; } } finally { pool . markAsyncCreationDone ( ) ; // mark the end of async } } } ) ; } catch ( RejectedExecutionException e ) { pool . markAsyncCreationDone ( ) ; // mark the end of async when reject throw e ; } } // end of NOT warm up } // end of if }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcClient.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcClient.java<CODESPLIT>Close all connections of a address<CODESPLIT>public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>Do something when closing .<CODESPLIT>public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>Close the connection .<CODESPLIT>public void close ( ) { if ( closed . compareAndSet ( false , true ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>src/main/java/com/alipay/remoting/Connection.java<CODESPLIT>set attribute if key absent .<CODESPLIT>public Object setAttributeIfAbsent ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/UserProcessorRegisterHelper.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/UserProcessorRegisterHelper.java<CODESPLIT>Help register single - interest user processor .<CODESPLIT>public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/UserProcessorRegisterHelper.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/UserProcessorRegisterHelper.java<CODESPLIT>Help register multi - interest user processor .<CODESPLIT>private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>dispatch request command to user processor<CODESPLIT>private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ; // processor here must not be null, for it have been checked before UserProcessor processor = ctx . getUserProcessor ( cmd . getRequestClass ( ) ) ; if ( processor instanceof AsyncUserProcessor ) { try { processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , new RpcAsyncContext ( ctx , cmd , this ) , cmd . getRequestObject ( ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do ASYNC process in RpcRequestProcessor" ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; } catch ( Throwable t ) { String errMsg = "AYSNC process rpc request failed in RpcRequestProcessor, id=" + id ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; } } else { try { Object responseObject = processor . handleRequest ( processor . preHandleRequest ( ctx , cmd . getRequestObject ( ) ) , cmd . getRequestObject ( ) ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createResponse ( responseObject , cmd ) ) ; } catch ( RejectedExecutionException e ) { logger . warn ( "RejectedExecutionException occurred when do SYNC process in RpcRequestProcessor" ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , ResponseStatus . SERVER_THREADPOOL_BUSY ) ) ; } catch ( Throwable t ) { String errMsg = "SYNC process rpc request failed in RpcRequestProcessor, id=" + id ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , type , this . getCommandFactory ( ) . createExceptionResponse ( id , t , errMsg ) ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>deserialize request command<CODESPLIT>private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = true ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = false ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = false ; } return result ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>pre process remoting context initial some useful infos and pass to biz<CODESPLIT>private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>print some log when request timeout and discarded in io thread .<CODESPLIT>private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/protocol/RpcRequestProcessor.java<CODESPLIT>print some debug log when receive request<CODESPLIT>private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/AbstractRemotingProcessor.java<CODESPLIT>src/main/java/com/alipay/remoting/AbstractRemotingProcessor.java<CODESPLIT>Process the remoting command with its own executor or with the defaultExecutor if its own if null .<CODESPLIT>@ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/BaseRemoting.java<CODESPLIT>src/main/java/com/alipay/remoting/BaseRemoting.java<CODESPLIT>Invocation with callback .<CODESPLIT>protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/BaseRemoting.java<CODESPLIT>src/main/java/com/alipay/remoting/BaseRemoting.java<CODESPLIT>Oneway invocation .<CODESPLIT>protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/config/switches/ProtocolSwitch.java<CODESPLIT>src/main/java/com/alipay/remoting/config/switches/ProtocolSwitch.java<CODESPLIT>from bit set to byte<CODESPLIT>public static byte toByte ( BitSet bs ) { int value = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { value += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/config/switches/ProtocolSwitch.java<CODESPLIT>src/main/java/com/alipay/remoting/config/switches/ProtocolSwitch.java<CODESPLIT>from byte to bit set<CODESPLIT>public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ReconnectManager.java<CODESPLIT>src/main/java/com/alipay/remoting/ReconnectManager.java<CODESPLIT>add reconnect task<CODESPLIT>public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ReconnectManager.java<CODESPLIT>src/main/java/com/alipay/remoting/ReconnectManager.java<CODESPLIT>stop reconnect thread<CODESPLIT>public void stop ( ) { if ( ! this . started ) { return ; } this . started = false ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcRemoting.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcRemoting.java<CODESPLIT>Convert application request object to remoting request command .<CODESPLIT>protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) { // set client custom serializer for request command if not null Object clientCustomSerializer = invokeContext . get ( InvokeContext . BOLT_CUSTOM_SERIALIZER ) ; if ( null != clientCustomSerializer ) { try { command . setSerializer ( ( Byte ) clientCustomSerializer ) ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( "Illegal custom serializer [" + clientCustomSerializer + "], the type of value should be [byte], but now is [" + clientCustomSerializer . getClass ( ) . getName ( ) + "]." ) ; } } // enable crc by default, user can disable by set invoke context `false` for key `InvokeContext.BOLT_CRC_SWITCH` Boolean crcSwitch = invokeContext . get ( InvokeContext . BOLT_CRC_SWITCH , ProtocolSwitch . CRC_SWITCH_DEFAULT_VALUE ) ; if ( null != crcSwitch && crcSwitch ) { command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX } ) ) ; } } else { // enable crc by default, if there is no invoke context. command . setProtocolSwitch ( ProtocolSwitch . create ( new int [ ] { ProtocolSwitch . CRC_SWITCH_INDEX } ) ) ; } command . setTimeout ( timeoutMillis ) ; command . setRequestClass ( request . getClass ( ) . getName ( ) ) ; command . setInvokeContext ( invokeContext ) ; command . serialize ( ) ; logDebugInfo ( command ) ; return command ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>Filter connections to monitor<CODESPLIT>@ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>Monitor connections and close connections with status is off<CODESPLIT>@ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>src/main/java/com/alipay/remoting/ScheduledDisconnectStrategy.java<CODESPLIT>close the connection of the fresh select connections<CODESPLIT>private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/config/ConfigManager.java<CODESPLIT>src/main/java/com/alipay/remoting/config/ConfigManager.java<CODESPLIT>~~~ public helper methods to retrieve system property<CODESPLIT>public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventHandler.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionEventHandler.java<CODESPLIT>print info log<CODESPLIT>private void infoLog ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/RemotingContext.java<CODESPLIT>src/main/java/com/alipay/remoting/RemotingContext.java<CODESPLIT>whether this request already timeout<CODESPLIT>public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return true ; } return false ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/RemotingContext.java<CODESPLIT>src/main/java/com/alipay/remoting/RemotingContext.java<CODESPLIT>Get user processor for class name .<CODESPLIT>public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/RandomSelectStrategy.java<CODESPLIT>src/main/java/com/alipay/remoting/RandomSelectStrategy.java<CODESPLIT>get one connection randomly<CODESPLIT>private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/InvokeContext.java<CODESPLIT>src/main/java/com/alipay/remoting/InvokeContext.java<CODESPLIT>get and use default if not found<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/Url.java<CODESPLIT>src/main/java/com/alipay/remoting/Url.java<CODESPLIT>Get property value according to property key<CODESPLIT>public String getProperty ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>Analyze the response command and generate the response object .<CODESPLIT>public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>Convert remoting response command to application response object .<CODESPLIT>private static Object toResponseObject ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>Convert remoting response command to throwable if it is a throwable otherwise return null .<CODESPLIT>private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcResponseResolver.java<CODESPLIT>Detail your error msg with the error msg returned from response command<CODESPLIT>private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcCommandFactory.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcCommandFactory.java<CODESPLIT>create server exception using error msg and fill the stack trace using the stack trace of throwable .<CODESPLIT>private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/TraceLogUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/TraceLogUtil.java<CODESPLIT>print trace log<CODESPLIT>public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/NettyEventLoopUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/NettyEventLoopUtil.java<CODESPLIT>Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .<CODESPLIT>public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the remote address of the channel .<CODESPLIT>public static String parseRemoteAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress remote = channel . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the local address of the channel .<CODESPLIT>public static String parseLocalAddress ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the remote host ip of the channel .<CODESPLIT>public static String parseRemoteIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the remote hostname of the channel .<CODESPLIT>public static String parseRemoteHostName ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the local host ip of the channel .<CODESPLIT>public static String parseLocalIP ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the remote host port of the channel .<CODESPLIT>public static int parseRemotePort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the local host port of the channel .<CODESPLIT>public static int parseLocalPort ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>src/main/java/com/alipay/remoting/util/RemotingUtil.java<CODESPLIT>Parse the host ip of socket address .<CODESPLIT>public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>add a connection<CODESPLIT>public void add ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>removeAndTryClose a connection<CODESPLIT>public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>src/main/java/com/alipay/remoting/ConnectionPool.java<CODESPLIT>get a connection<CODESPLIT>public Connection get ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>Register custom serializer for class name .<CODESPLIT>public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>Get the custom serializer for class name .<CODESPLIT>public static CustomSerializer getCustomSerializer ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>Register custom serializer for command code .<CODESPLIT>public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
1<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>src/main/java/com/alipay/remoting/CustomSerializerManager.java<CODESPLIT>Get the custom serializer for command code .<CODESPLIT>public static CustomSerializer getCustomSerializer ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionMonitor.java<CODESPLIT>src/main/java/com/alipay/remoting/DefaultConnectionMonitor.java<CODESPLIT>Start schedule task<CODESPLIT>public void start ( ) { /** initial delay to execute schedule task, unit: ms */ long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; /** period of schedule task, unit: ms*/ long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , true ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcServer.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcServer.java<CODESPLIT>check whether a client address connected<CODESPLIT>public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
1<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcServer.java<CODESPLIT>src/main/java/com/alipay/remoting/rpc/RpcServer.java<CODESPLIT>init netty write buffer water mark<CODESPLIT>private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/framing/FramedataImpl1.java<CODESPLIT>src/main/java/org/java_websocket/framing/FramedataImpl1.java<CODESPLIT>Get a frame with a specific opcode<CODESPLIT>public static FramedataImpl1 get ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/SocketChannelIOHelper.java<CODESPLIT>src/main/java/org/java_websocket/SocketChannelIOHelper.java<CODESPLIT>Returns whether the whole outQueue has been flushed<CODESPLIT>public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return false ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do { // FIXME writing as much as possible is unfair!! /*int written = */ sockchannel . write ( buffer ) ; if ( buffer . remaining ( ) > 0 ) { return false ; } else { ws . outQueue . poll ( ) ; // Buffer finished. Remove it. buffer = ws . outQueue . peek ( ) ; } } while ( buffer != null ) ; } if ( ws . outQueue . isEmpty ( ) && ws . isFlushAndClose ( ) && ws . getDraft ( ) != null && ws . getDraft ( ) . getRole ( ) != null && ws . getDraft ( ) . getRole ( ) == Role . SERVER ) { // ws . closeConnection ( ) ; } return c == null || ! ( ( WrappedByteChannel ) sockchannel ) . isNeedWrite ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>Set the close code for this close frame<CODESPLIT>public void setCode ( int code ) { this . code = code ; // CloseFrame.TLS_ERROR is not allowed to be transfered over the wire if ( code == CloseFrame . TLS_ERROR ) { this . code = CloseFrame . NOCODE ; this . reason = "" ; } updatePayload ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>Validate the payload to valid utf8<CODESPLIT>private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>src/main/java/org/java_websocket/framing/CloseFrame.java<CODESPLIT>Update the payload to represent the close code and the reason<CODESPLIT>private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Check if the requested protocol is part of this draft<CODESPLIT>private HandshakeState containsRequestedProtocol ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Check if the frame size exceeds the allowed limit<CODESPLIT>private void translateSingleFrameCheckLengthLimit ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Check if the max packet size is smaller than the real packet size<CODESPLIT>private void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Generate a final key from a input string<CODESPLIT>private String generateFinalKey ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is a continuous frame or the fin bit is not set<CODESPLIT>private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } //Check if the whole payload is valid utf8, when the opcode indicates a text if ( curop == Opcode . TEXT && ! Charsetfunctions . isValidUTF8 ( frame . getPayloadData ( ) ) ) { log . error ( "Protocol error: Payload is not UTF8" ) ; throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } //Checking if the current continuous frame contains a correct payload with the other frames combined if ( curop == Opcode . CONTINUOUS && currentContinuousFrame != null ) { addToBufferList ( frame . getPayloadData ( ) ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is a binary frame<CODESPLIT>private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Log the runtime exception to the specific WebSocketImpl<CODESPLIT>private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is a text frame<CODESPLIT>private void processFrameText ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is the last frame<CODESPLIT>private void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is not the last frame<CODESPLIT>private void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Process the frame if it is a closing frame<CODESPLIT>private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) { // complete the close handshake by disconnecting webSocketImpl . closeConnection ( code , reason , true ) ; } else { // echo close handshake if ( getCloseHandshakeType ( ) == CloseHandshakeType . TWOWAY ) webSocketImpl . close ( code , reason , true ) ; else webSocketImpl . flushAndClose ( code , reason , false ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size<CODESPLIT>private void checkBufferLimit ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Method to generate a full bytebuffer out of all the fragmented frame payload<CODESPLIT>private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft_6455.java<CODESPLIT>Get the current size of the resulting bytebuffer in the bytebuffer list<CODESPLIT>private long getByteBufferListSize ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft.java<CODESPLIT>Checking the handshake for the role as server<CODESPLIT>private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { // translating/parsing the request from the CLIENT if ( ! "GET" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid request method received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 2 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 2 ] , line ) ) ; } ClientHandshakeBuilder clienthandshake = new HandshakeImpl1Client ( ) ; clienthandshake . setResourceDescriptor ( firstLineTokens [ 1 ] ) ; return clienthandshake ; }
1<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft.java<CODESPLIT>src/main/java/org/java_websocket/drafts/Draft.java<CODESPLIT>Checking the handshake for the role as client<CODESPLIT>private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException { // translating/parsing the response from the SERVER if ( ! "101" . equals ( firstLineTokens [ 1 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status code received: %s Status line: %s" , firstLineTokens [ 1 ] , line ) ) ; } if ( ! "HTTP/1.1" . equalsIgnoreCase ( firstLineTokens [ 0 ] ) ) { throw new InvalidHandshakeException ( String . format ( "Invalid status line received: %s Status line: %s" , firstLineTokens [ 0 ] , line ) ) ; } HandshakeBuilder handshake = new HandshakeImpl1Server ( ) ; ServerHandshakeBuilder serverhandshake = ( ServerHandshakeBuilder ) handshake ; serverhandshake . setHttpStatus ( Short . parseShort ( firstLineTokens [ 1 ] ) ) ; serverhandshake . setHttpStatusMessage ( firstLineTokens [ 2 ] ) ; return handshake ; }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>Method to decode the provided ByteBuffer<CODESPLIT>public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ; // the buffers will never have remaining bytes at the same time if ( socketBuffer . hasRemaining ( ) ) { decodeFrames ( socketBuffer ) ; } else if ( tmpHandshakeBytes . hasRemaining ( ) ) { decodeFrames ( tmpHandshakeBytes ) ; } } } }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>Close the connection if the received handshake was not correct<CODESPLIT>private void closeConnectionDueToWrongHandshake ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , false ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>Close the connection if there was a server error by a RuntimeException<CODESPLIT>private void closeConnectionDueToInternalServerError ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , false ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>Generate a simple response for the corresponding endpoint to indicate some error<CODESPLIT>private ByteBuffer generateHttpResponseDueToError ( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketImpl.java<CODESPLIT>Send Text data to the other end .<CODESPLIT>@ Override public void send ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; send ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>Reset everything relevant to allow a reconnect<CODESPLIT>private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>Initiates the websocket connection . This method does not block .<CODESPLIT>public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>Extract the specified port<CODESPLIT>private int getPort ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
1<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>src/main/java/org/java_websocket/client/WebSocketClient.java<CODESPLIT>Create and send the handshake to the other endpoint<CODESPLIT>private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated<CODESPLIT>public void setConnectionLostTimeout ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ; //Reset all the pings try { ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( getConnections ( ) ) ; WebSocketImpl webSocketImpl ; for ( WebSocket conn : connections ) { if ( conn instanceof WebSocketImpl ) { webSocketImpl = ( WebSocketImpl ) conn ; webSocketImpl . updateLastPong ( ) ; } } } catch ( Exception e ) { log . error ( "Exception during connection lost restart" , e ) ; } restartConnectionLostTimer ( ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>Stop the connection lost timer<CODESPLIT>protected void stopConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = false ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>Start the connection lost timer<CODESPLIT>protected void startConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = true ; restartConnectionLostTimer ( ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>This methods allows the reset of the connection lost timer in case of a changed parameter<CODESPLIT>private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { /** 			 * Keep the connections in a separate list to not cause deadlocks 			 */ private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) { //Ignore this exception } connections . clear ( ) ; } } ; connectionLostCheckerFuture = connectionLostCheckerService . scheduleAtFixedRate ( connectionLostChecker , connectionLostTimeout , connectionLostTimeout , TimeUnit . NANOSECONDS ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping<CODESPLIT>private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>src/main/java/org/java_websocket/AbstractWebSocket.java<CODESPLIT>Cancel any running timer for the connection lost detection<CODESPLIT>private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( false ) ; connectionLostCheckerFuture = null ; } }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketAdapter.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketAdapter.java<CODESPLIT>This default implementation does not do anything . Go ahead and overwrite it .<CODESPLIT>@ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/WebSocketAdapter.java<CODESPLIT>src/main/java/org/java_websocket/WebSocketAdapter.java<CODESPLIT>This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .<CODESPLIT>@ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .<CODESPLIT>public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( false , true ) ) { // this also makes sure that no further connections will be added to this.connections return ; } List < WebSocket > socketsToClose ; // copy the connections in a list (prevent callback deadlocks) synchronized ( connections ) { socketsToClose = new ArrayList < WebSocket > ( connections ) ; } for ( WebSocket ws : socketsToClose ) { ws . close ( CloseFrame . GOING_AWAY ) ; } wsf . close ( ) ; synchronized ( this ) { if ( selectorthread != null && selector != null ) { selector . wakeup ( ) ; selectorthread . join ( timeout ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Gets the port number that this server listens on .<CODESPLIT>public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Do an additional read<CODESPLIT>private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Execute a accept operation<CODESPLIT>private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( false ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( true ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Execute a read operation<CODESPLIT>private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return false ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return true ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Execute a write operation<CODESPLIT>private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Setup the selector thread as well as basic server settings<CODESPLIT>private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( false ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return false ; } return true ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>The websocket server can only be started once<CODESPLIT>private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return false ; } } return true ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Clean up everything after a shutdown<CODESPLIT>private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Getter to return the socket used by this specific connection<CODESPLIT>private Socket getSocket ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Send a byte array to a specific collection of websocket connections<CODESPLIT>public void broadcast ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , clients ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Send a text to a specific collection of websocket connections<CODESPLIT>public void broadcast ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Private method to cache all the frames to improve memory footprint and conversion time<CODESPLIT>private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) { //Ignore this exception in this case } } } }
1<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>src/main/java/org/java_websocket/server/WebSocketServer.java<CODESPLIT>Fills the draftFrames with new data for the broadcast<CODESPLIT>private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , false ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , false ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
1<CODESPLIT>src/main/java/org/java_websocket/util/ByteBufferUtils.java<CODESPLIT>src/main/java/org/java_websocket/util/ByteBufferUtils.java<CODESPLIT>Transfer from one ByteBuffer to another ByteBuffer<CODESPLIT>public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>Initialise JPA entity manager factories .<CODESPLIT>public JPAApi start ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>Get a newly created EntityManager for the specified persistence unit name .<CODESPLIT>public EntityManager em ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAApi.java<CODESPLIT>Run a block of code with a newly created EntityManager for the default Persistence Unit .<CODESPLIT>public void withTransaction ( Consumer < EntityManager > block ) { withTransaction ( em -> { block . accept ( em ) ; return null ; } ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary<CODESPLIT>private static Seq < Object > convertArgsToScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Wraps arguments passed into a list if necessary .<CODESPLIT>@ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Translates a message .<CODESPLIT>public String get ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , lang ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Translates the first defined message .<CODESPLIT>public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Check if a message key is defined .<CODESPLIT>public Boolean isDefinedAt ( play . api . i18n . Lang lang , String key ) { return messages . isDefinedAt ( key , lang ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Get a messages context appropriate for the given candidates .<CODESPLIT>public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Get a messages context appropriate for the given request .<CODESPLIT>public Messages preferred ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesApi.java<CODESPLIT>Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .<CODESPLIT>public Result setLang ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Add bindings from guiceable modules .<CODESPLIT>public final Self bindings ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Add bindings from Play modules .<CODESPLIT>public final Self bindings ( play . api . inject . Module ... modules ) { return bindings ( Guiceable . modules ( modules ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Add Play bindings .<CODESPLIT>public final Self bindings ( play . api . inject . Binding < ? > ... bindings ) { return bindings ( Guiceable . bindings ( bindings ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Override bindings using guiceable modules .<CODESPLIT>public final Self overrides ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules ) ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Override bindings using Play modules .<CODESPLIT>public final Self overrides ( play . api . inject . Module ... modules ) { return overrides ( Guiceable . modules ( modules ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Override bindings using Play bindings .<CODESPLIT>public final Self overrides ( play . api . inject . Binding < ? > ... bindings ) { return overrides ( Guiceable . bindings ( bindings ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceBuilder.java<CODESPLIT>Disable modules by class .<CODESPLIT>public final Self disable ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Action.java<CODESPLIT>core/play/src/main/java/play/mvc/Action.java<CODESPLIT>Executes this action with the given HTTP context and returns the result .<CODESPLIT>@ Deprecated // TODO: When you remove this method make call(Request) below abstract public CompletionStage < Result > call ( Context ctx ) { return call ( ctx . args != null && ! ctx . args . isEmpty ( ) ? ctx . request ( ) . addAttr ( CTX_ARGS , ctx . args ) : ctx . request ( ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Action.java<CODESPLIT>core/play/src/main/java/play/mvc/Action.java<CODESPLIT>Executes this action with the given HTTP request and returns the result .<CODESPLIT>public CompletionStage < Result > call ( Request req ) { // TODO: Make this method abstract after removing call(Context) return Context . safeCurrent ( ) . map ( threadLocalCtx -> { // A previous action did explicitly set a context onto the thread local (via // Http.Context.current.set(...)) // Let's use that context so the user doesn't loose data he/she set onto that ctx // (args,...) Context newCtx = threadLocalCtx . withRequest ( req . removeAttr ( CTX_ARGS ) ) ; Context . setCurrent ( newCtx ) ; return call ( newCtx ) ; } ) . orElseGet ( ( ) -> { // A previous action did not set a context explicitly, we simply create a new one to // pass on the request Context ctx = new Context ( req . removeAttr ( CTX_ARGS ) , contextComponents ) ; ctx . args = req . attrs ( ) . getOptional ( CTX_ARGS ) . orElse ( new HashMap <> ( ) ) ; return call ( ctx ) ; } ) ; }
1<CODESPLIT>core/play/src/main/java/play/Environment.java<CODESPLIT>core/play/src/main/java/play/Environment.java<CODESPLIT>Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .<CODESPLIT>public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/Binding.java<CODESPLIT>core/play/src/main/java/play/inject/Binding.java<CODESPLIT>Configure the scope for this binding .<CODESPLIT>public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>Constructs a tuple of A B<CODESPLIT>public static < A , B > Tuple < A , B > Tuple ( A a , B b ) { return new Tuple < A , B > ( a , b ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>Constructs a tuple of A B C D E<CODESPLIT>public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , e ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>core/play/src/main/java/play/libs/F.java<CODESPLIT>Converts the execution context to an executor preparing it first .<CODESPLIT>private static Executor toExecutor ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>Create a default JPA configuration with the given name and unit name .<CODESPLIT>public static JPAConfig of ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>Create a default JPA configuration with the given names and unit names .<CODESPLIT>public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/DefaultJPAConfig.java<CODESPLIT>Create a default JPA configuration from a map of names to unit names .<CODESPLIT>public static JPAConfig from ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
1<CODESPLIT>core/play-java/src/main/java/play/libs/Comet.java<CODESPLIT>core/play-java/src/main/java/play/libs/Comet.java<CODESPLIT>Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .<CODESPLIT>public static Flow < String , ByteString , NotUsed > string ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
1<CODESPLIT>core/play-java/src/main/java/play/libs/Comet.java<CODESPLIT>core/play-java/src/main/java/play/libs/Comet.java<CODESPLIT>Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .<CODESPLIT>public static Flow < JsonNode , ByteString , NotUsed > json ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( callbackName ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/MappedConstraintValidatorFactory.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/MappedConstraintValidatorFactory.java<CODESPLIT>Adds validator as a singleton .<CODESPLIT>public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/MappedConstraintValidatorFactory.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/MappedConstraintValidatorFactory.java<CODESPLIT>need to do so .<CODESPLIT>private < T extends ConstraintValidator < ? , ? > > T newInstance ( Class < T > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/MethodUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/MethodUtils.java<CODESPLIT>Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .<CODESPLIT>public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) { // NOPMD - Swallow the exception } // search through all methods Method bestMatch = null ; final Method [ ] methods = cls . getMethods ( ) ; for ( final Method method : methods ) { // compare name and parameters if ( method . getName ( ) . equals ( methodName ) && MemberUtils . isMatchingMethod ( method , parameterTypes ) ) { // get accessible version of method final Method accessibleMethod = getAccessibleMethod ( method ) ; if ( accessibleMethod != null && ( bestMatch == null || MemberUtils . compareMethodFit ( accessibleMethod , bestMatch , parameterTypes ) < 0 ) ) { bestMatch = accessibleMethod ; } } } if ( bestMatch != null ) { MemberUtils . setAccessibleWorkaround ( bestMatch ) ; } if ( bestMatch != null && bestMatch . isVarArgs ( ) && bestMatch . getParameterTypes ( ) . length > 0 && parameterTypes . length > 0 ) { final Class < ? > [ ] methodParameterTypes = bestMatch . getParameterTypes ( ) ; final Class < ? > methodParameterComponentType = methodParameterTypes [ methodParameterTypes . length - 1 ] . getComponentType ( ) ; final String methodParameterComponentTypeName = ClassUtils . primitiveToWrapper ( methodParameterComponentType ) . getName ( ) ; final String parameterTypeName = parameterTypes [ parameterTypes . length - 1 ] . getName ( ) ; final String parameterTypeSuperClassName = parameterTypes [ parameterTypes . length - 1 ] . getSuperclass ( ) . getName ( ) ; if ( ! methodParameterComponentTypeName . equals ( parameterTypeName ) && ! methodParameterComponentTypeName . equals ( parameterTypeSuperClassName ) ) { return null ; } } return bestMatch ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked when a client error occurs that is an error in the 4xx series .<CODESPLIT>@ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked when a client makes a bad request .<CODESPLIT>protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked when a client makes a request that was forbidden .<CODESPLIT>protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked when a handler or resource is not found .<CODESPLIT>protected CompletionStage < Result > onNotFound ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked when a server error occurs .<CODESPLIT>@ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Responsible for logging server errors .<CODESPLIT>protected void logServerError ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Convert the given exception to an exception that Play can report more information about .<CODESPLIT>protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .<CODESPLIT>protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>core/play/src/main/java/play/http/DefaultHttpErrorHandler.java<CODESPLIT>Invoked in prod mode when a server error occurs .<CODESPLIT>protected CompletionStage < Result > onProdServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , request . asScala ( ) ) ) ) ; }
1<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .<CODESPLIT>public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else { // Assume it's a jar file JarFile jarFile = new JarFile ( file ) ; jarFiles . add ( jarFile ) ; repositories [ i ] = new JarRepository ( jarFile , Option . apply ( baseDir ) ) ; } } return new DocumentationHandler ( new AggregateFileRepository ( repositories ) , ( ) -> { for ( JarFile jarFile : jarFiles ) { jarFile . close ( ) ; } } ) ; }
1<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .<CODESPLIT>public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
1<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository<CODESPLIT>public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base , false ) ; }
1<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .<CODESPLIT>public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
1<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>dev-mode/play-docs/src/main/java/play/docs/BuildDocHandlerFactory.java<CODESPLIT>Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .<CODESPLIT>public static BuildDocHandler fromJar ( JarFile jarFile , String base ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( base ) ) ; return new DocumentationHandler ( repo ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>Consumes the data .<CODESPLIT>public CompletionStage < ByteString > consumeData ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>Create an entity from the given content .<CODESPLIT>public static final HttpEntity fromContent ( Content content , String charset ) { String body ; if ( content instanceof Xml ) { // See https://github.com/playframework/playframework/issues/2770 body = content . body ( ) . trim ( ) ; } else { body = content . body ( ) ; } return new Strict ( ByteString . fromString ( body , charset ) , Optional . of ( content . contentType ( ) + "; charset=" + charset ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>Create an entity from the given String .<CODESPLIT>public static final HttpEntity fromString ( String content , String charset ) { return new Strict ( ByteString . fromString ( content , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>core/play/src/main/java/play/http/HttpEntity.java<CODESPLIT>Convert the given source of ByteStrings to a chunked entity .<CODESPLIT>public static final HttpEntity chunked ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>Generates a simple result with json content and UTF8 encoding .<CODESPLIT>public static Result status ( int status , JsonNode content ) { return status ( status , content , JsonEncoding . UTF8 ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>Generates a simple result with json content .<CODESPLIT>public static Result status ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( content , encoding ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>Generates a simple result with byte - array content .<CODESPLIT>public static Result status ( int status , byte [ ] content ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( content ) , Optional . empty ( ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>Generates a chunked result .<CODESPLIT>public static Result status ( int status , InputStream content , long contentLength ) { return status ( status ) . sendInputStream ( content , contentLength ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>core/play/src/main/java/play/mvc/Results.java<CODESPLIT>Generates a result with file contents .<CODESPLIT>public static Result status ( int status , File content ) { return status ( status , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
1<CODESPLIT>documentation/manual/working/javaGuide/advanced/routing/code/javaguide/binder/models/User.java<CODESPLIT>documentation/manual/working/javaGuide/advanced/routing/code/javaguide/binder/models/User.java<CODESPLIT>designed to be lightweight operation<CODESPLIT>private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/Langs.java<CODESPLIT>core/play/src/main/java/play/i18n/Langs.java<CODESPLIT>Select a preferred language given the list of candidates .<CODESPLIT>public Lang preferred ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>Append a unique identifier to the URL .<CODESPLIT>public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>Returns a new Call with the given fragment .<CODESPLIT>public Call withFragment ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>Transform this call to an absolute URL .<CODESPLIT>public String absoluteURL ( Http . Request request ) { return absoluteURL ( request . secure ( ) , request . host ( ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>core/play/src/main/java/play/mvc/Call.java<CODESPLIT>Transform this call to an WebSocket URL .<CODESPLIT>public String webSocketURL ( Http . Request request ) { return webSocketURL ( request . secure ( ) , request . host ( ) ) ; }
1<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java<CODESPLIT>Create a Scala function wrapper for ConnectionRunnable .<CODESPLIT>AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable block ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { block . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
1<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/DefaultDatabase.java<CODESPLIT>Create a Scala function wrapper for ConnectionCallable .<CODESPLIT>< A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return block . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
1<CODESPLIT>transport/server/play-server/src/main/java/play/server/Server.java<CODESPLIT>transport/server/play-server/src/main/java/play/server/Server.java<CODESPLIT>Create a server for the router returned by the given block .<CODESPLIT>public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( block ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>Converts an object to JsonNode .<CODESPLIT>public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
1<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>Converts a JsonNode to a Java value<CODESPLIT>public static < A > A fromJson ( JsonNode json , Class < A > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
1<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>Parses a String representing a json and return it as a JsonNode .<CODESPLIT>public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
1<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>core/play/src/main/java/play/libs/Json.java<CODESPLIT>Parses a InputStream representing a json and return it as a JsonNode .<CODESPLIT>public static JsonNode parse ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
1<CODESPLIT>core/play/src/main/java/play/core/Paths.java<CODESPLIT>core/play/src/main/java/play/core/Paths.java<CODESPLIT>Create a path to targetPath that s relative to the given startPath .<CODESPLIT>public static String relative ( String startPath , String targetPath ) { // If the start and target path's are the same then link to the current directory if ( startPath . equals ( targetPath ) ) { return CURRENT_DIR ; } String [ ] start = toSegments ( canonical ( startPath ) ) ; String [ ] target = toSegments ( canonical ( targetPath ) ) ; // If start path has no trailing separator (a "file" path), then drop file segment if ( ! startPath . endsWith ( SEPARATOR ) ) start = Arrays . copyOfRange ( start , 0 , start . length - 1 ) ; // If target path has no trailing separator, then drop file segment, but keep a reference to add // it later String targetFile = "" ; if ( ! targetPath . endsWith ( SEPARATOR ) ) { targetFile = target [ target . length - 1 ] ; target = Arrays . copyOfRange ( target , 0 , target . length - 1 ) ; } // Work out how much of the filepath is shared by start and path. String [ ] common = commonPrefix ( start , target ) ; String [ ] parents = toParentDirs ( start . length - common . length ) ; int relativeStartIdx = common . length ; String [ ] relativeDirs = Arrays . copyOfRange ( target , relativeStartIdx , target . length ) ; String [ ] relativePath = Arrays . copyOf ( parents , parents . length + relativeDirs . length ) ; System . arraycopy ( relativeDirs , 0 , relativePath , parents . length , relativeDirs . length ) ; // If this is not a sibling reference append a trailing / to path String trailingSep = "" ; if ( relativePath . length > 0 ) trailingSep = SEPARATOR ; return Arrays . stream ( relativePath ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep + targetFile ; }
1<CODESPLIT>core/play/src/main/java/play/core/Paths.java<CODESPLIT>core/play/src/main/java/play/core/Paths.java<CODESPLIT>Create a canonical path that does not contain parent directories current directories or superfluous directory separators .<CODESPLIT>public static String canonical ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > canonical = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! canonical . empty ( ) && canonical . peek ( ) . equals ( PARENT_DIR ) ) ) canonical . push ( comp ) ; else canonical . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + canonical . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/Constraints.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/Constraints.java<CODESPLIT>Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .<CODESPLIT>public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/Constraints.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/validation/Constraints.java<CODESPLIT>Converts a constraint to a human - readable value .<CODESPLIT>public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > constraint ) { final Display displayAnnotation = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/concurrent/DefaultFutures.java<CODESPLIT>core/play/src/main/java/play/libs/concurrent/DefaultFutures.java<CODESPLIT>Creates a CompletionStage that returns either the input stage or a futures .<CODESPLIT>@ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > stage , final long amount , final TimeUnit unit ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/ClassUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/ClassUtils.java<CODESPLIT>Checks if an array of Classes can be assigned to another array of Classes .<CODESPLIT>public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return false ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( isAssignable ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == false ) { return false ; } } return true ; }
1<CODESPLIT>core/play-java/src/main/java/play/libs/Time.java<CODESPLIT>core/play-java/src/main/java/play/libs/Time.java<CODESPLIT>Parses a CRON expression .<CODESPLIT>public static Date parseCRONExpression ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
1<CODESPLIT>core/play-java/src/main/java/play/libs/Time.java<CODESPLIT>core/play-java/src/main/java/play/libs/Time.java<CODESPLIT>Compute the number of milliseconds between the next valid date and the one after .<CODESPLIT>public static long cronInterval ( String cron , Date date ) { try { return new CronExpression ( cron ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
1<CODESPLIT>transport/client/play-ahc-ws/src/main/java/play/libs/ws/ahc/AhcWSClient.java<CODESPLIT>transport/client/play-ahc-ws/src/main/java/play/libs/ws/ahc/AhcWSClient.java<CODESPLIT>Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .<CODESPLIT>public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationLoader.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationLoader.java<CODESPLIT>Construct a builder to use for loading the given context .<CODESPLIT>public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>Generates a 501 NOT_IMPLEMENTED simple result .<CODESPLIT>public static Result TODO ( Request request ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( request . asScala ( ) ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>Puts a new value into the current session .<CODESPLIT>@ Deprecated public static void session ( String key , String value ) { session ( ) . put ( key , value ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>core/play/src/main/java/play/mvc/Controller.java<CODESPLIT>Puts a new value into the flash scope .<CODESPLIT>@ Deprecated public static void flash ( String key , String value ) { flash ( ) . put ( key , value ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Qualify this binding key with the given instance of an annotation .<CODESPLIT>public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Qualify this binding key with the given annotation .<CODESPLIT>public < A extends Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Bind this binding key to the given implementation class .<CODESPLIT>public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Bind this binding key to the given provider instance .<CODESPLIT>public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Bind this binding key to the given instance .<CODESPLIT>public < A extends T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Bind this binding key to another binding key .<CODESPLIT>public Binding < T > to ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>core/play/src/main/java/play/inject/BindingKey.java<CODESPLIT>Bind this binding key to the given provider class .<CODESPLIT>public < P extends Provider < ? extends T > > Binding < T > toProvider ( final Class < P > provider ) { return underlying . toProvider ( provider ) . asJava ( ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/Lang.java<CODESPLIT>core/play/src/main/java/play/i18n/Lang.java<CODESPLIT>Retrieve Lang availables from the application configuration .<CODESPLIT>public static List < Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/Lang.java<CODESPLIT>core/play/src/main/java/play/i18n/Lang.java<CODESPLIT>Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .<CODESPLIT>public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
1<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>Create an evolutions reader based on a simple map of database names to evolutions .<CODESPLIT>public static play . api . db . evolutions . EvolutionsReader fromMap ( Map < String , List < Evolution > > evolutions ) { return new SimpleEvolutionsReader ( evolutions ) ; }
1<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>Create an evolutions reader for the default database from a list of evolutions .<CODESPLIT>public static play . api . db . evolutions . EvolutionsReader forDefault ( Evolution ... evolutions ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( evolutions ) ) ; return fromMap ( map ) ; }
1<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>persistence/play-jdbc-evolutions/src/main/java/play/db/evolutions/Evolutions.java<CODESPLIT>Cleanup evolutions for the given database .<CODESPLIT>public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Set the initial configuration loader . Overrides the default or any previously configured values .<CODESPLIT>public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Set the module loader . Overrides the default or any previously configured values .<CODESPLIT>public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Override the module loader with the given guiceable modules .<CODESPLIT>public GuiceApplicationBuilder load ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Override the module loader with the given Guice modules .<CODESPLIT>public GuiceApplicationBuilder load ( com . google . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Override the module loader with the given Play modules .<CODESPLIT>public GuiceApplicationBuilder load ( play . api . inject . Module ... modules ) { return load ( Guiceable . modules ( modules ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Override the module loader with the given Play bindings .<CODESPLIT>public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... bindings ) { return load ( Guiceable . bindings ( bindings ) ) ; }
1<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>core/play-guice/src/main/java/play/inject/guice/GuiceApplicationBuilder.java<CODESPLIT>Implementation of Self creation for GuiceBuilder .<CODESPLIT>protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
1<CODESPLIT>core/play/src/main/java/play/core/cookie/encoding/ClientCookieEncoder.java<CODESPLIT>core/play/src/main/java/play/core/cookie/encoding/ClientCookieEncoder.java<CODESPLIT>Encodes the specified cookie into a Cookie header value .<CODESPLIT>public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>Get the default EntityManager for this thread .<CODESPLIT>public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( true ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>Get the EntityManager stack .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> { // Not a web request if ( threadLocalFallback ) { return this . get ( ) ; } else { throw new RuntimeException ( "No Http.Context is present. If you want to invoke this method outside of a HTTP request, you need to wrap the call with JPA.withTransaction instead." ) ; } } ) ; }
1<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>persistence/play-java-jpa/src/main/java/play/db/jpa/JPAEntityManagerContext.java<CODESPLIT>Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .<CODESPLIT>void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
1<CODESPLIT>core/play/src/main/java/play/libs/streams/AkkaStreams.java<CODESPLIT>core/play/src/main/java/play/libs/streams/AkkaStreams.java<CODESPLIT>Bypass the given flow using the given splitter function .<CODESPLIT>public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
1<CODESPLIT>core/play/src/main/java/play/libs/streams/AkkaStreams.java<CODESPLIT>core/play/src/main/java/play/libs/streams/AkkaStreams.java<CODESPLIT>Using the given splitter flow allow messages to bypass a flow .<CODESPLIT>public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> { // Eager cancel must be true so that if the flow cancels, that will be propagated // upstream. // However, that means the bypasser must block cancel, since when this flow // finishes, the merge // will result in a cancel flowing up through the bypasser, which could lead to // dropped messages. // Using scaladsl here because of https://github.com/akka/akka/issues/18384 UniformFanOutShape < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > > broadcast = builder . add ( Broadcast . create ( 2 , true ) ) ; UniformFanInShape < Out , Out > merge = builder . add ( mergeStrategy ) ; Flow < F . Either < FlowIn , Out > , FlowIn , ? > collectIn = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . left . isPresent ( ) ) { return x . left . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , Out , ? > collectOut = Flow . < F . Either < FlowIn , Out > > create ( ) . collect ( Scala . partialFunction ( x -> { if ( x . right . isPresent ( ) ) { return x . right . get ( ) ; } else { throw Scala . noMatch ( ) ; } } ) ) ; Flow < F . Either < FlowIn , Out > , F . Either < FlowIn , Out > , ? > blockCancel = play . api . libs . streams . AkkaStreams . < F . Either < FlowIn , Out > > ignoreAfterCancellation ( ) . asJava ( ) ; // Normal flow builder . from ( broadcast . out ( 0 ) ) . via ( builder . add ( collectIn ) ) . via ( builder . add ( flow ) ) . toInlet ( merge . in ( 0 ) ) ; // Bypass flow, need to ignore downstream finish builder . from ( broadcast . out ( 1 ) ) . via ( builder . add ( blockCancel ) ) . via ( builder . add ( collectOut ) ) . toInlet ( merge . in ( 1 ) ) ; return new FlowShape <> ( broadcast . in ( ) , merge . out ( ) ) ; } ) ) ) ; }
1<CODESPLIT>core/play-streams/src/main/java/play/libs/streams/ActorFlow.java<CODESPLIT>core/play-streams/src/main/java/play/libs/streams/ActorFlow.java<CODESPLIT>Create a flow that is handled by an actor .<CODESPLIT>public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , mat ) . asJava ( ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>Convert the error arguments .<CODESPLIT>private List < Object > convertErrorArguments ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>Populates this form with an existing value used for edit forms .<CODESPLIT>public Form < T > fill ( T value ) { if ( value == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( value ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>Retrieve all global errors - errors without a key .<CODESPLIT>public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/Form.java<CODESPLIT>Returns the form errors serialized as Json using the given Lang .<CODESPLIT>public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/DynamicForm.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/DynamicForm.java<CODESPLIT>Gets the concrete value<CODESPLIT>public Optional < Object > value ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/DynamicForm.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/DynamicForm.java<CODESPLIT>Fills the form with existing data .<CODESPLIT>public DynamicForm fill ( Map < String , Object > value ) { Form < Dynamic > form = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Parses this string as instance of the given class .<CODESPLIT>public < T > T parse ( String text , Class < T > clazz ) { return conversion . convert ( text , clazz ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Parses this string as instance of a specific field<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Computes the display string for any value .<CODESPLIT>public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Computes the display string for any value for a specific field .<CODESPLIT>public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Computes the display string for any value for a specific type .<CODESPLIT>public < T > String print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( String . class ) ) ) { return ( String ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( String . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Converter for String - > Optional and Optional - > String<CODESPLIT>private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) { // From String to Optional Object element = conversion . convert ( source , sourceType , targetType . elementTypeDescriptor ( source ) ) ; return Optional . ofNullable ( element ) ; } else if ( targetType . getObjectType ( ) . equals ( String . class ) ) { // From Optional to String if ( source == null ) return "" ; Optional < ? > opt = ( Optional ) source ; return opt . map ( o -> conversion . convert ( source , sourceType . getElementTypeDescriptor ( ) , targetType ) ) . orElse ( "" ) ; } return null ; } public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < ConvertiblePair > result = new HashSet <> ( ) ; result . add ( new ConvertiblePair ( Optional . class , String . class ) ) ; result . add ( new ConvertiblePair ( String . class , Optional . class ) ) ; return result ; } } ) ; return this ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Registers a simple formatter .<CODESPLIT>public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
1<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>web/play-java-forms/src/main/java/play/data/format/Formatters.java<CODESPLIT>Registers an annotation - based formatter .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
1<CODESPLIT>core/play/src/main/java/play/core/cookie/encoding/ServerCookieEncoder.java<CODESPLIT>core/play/src/main/java/play/core/cookie/encoding/ServerCookieEncoder.java<CODESPLIT>Encodes the specified cookie into a Set - Cookie header value .<CODESPLIT>public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 ) // Set expires to the Unix epoch : new Date ( cookie . maxAge ( ) * 1000L + System . currentTimeMillis ( ) ) ; add ( buf , CookieHeaderNames . EXPIRES , HttpHeaderDateFormat . get ( ) . format ( expires ) ) ; } if ( cookie . sameSite ( ) != null ) { add ( buf , CookieHeaderNames . SAMESITE , cookie . sameSite ( ) ) ; } if ( cookie . path ( ) != null ) { add ( buf , CookieHeaderNames . PATH , cookie . path ( ) ) ; } if ( cookie . domain ( ) != null ) { add ( buf , CookieHeaderNames . DOMAIN , cookie . domain ( ) ) ; } if ( cookie . isSecure ( ) ) { add ( buf , CookieHeaderNames . SECURE ) ; } if ( cookie . isHttpOnly ( ) ) { add ( buf , CookieHeaderNames . HTTPONLY ) ; } return stripTrailingSeparator ( buf ) ; }
1<CODESPLIT>core/play-java/src/main/java/play/libs/XPath.java<CODESPLIT>core/play-java/src/main/java/play/libs/XPath.java<CODESPLIT>Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order<CODESPLIT>public static NodeList selectNodes ( String path , Object node ) { return selectNodes ( path , node , null ) ; }
1<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>Converts a Java List to Scala Seq .<CODESPLIT>public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
1<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>Converts a Java Array to Scala Seq .<CODESPLIT>public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] array ) { return toSeq ( java . util . Arrays . asList ( array ) ) ; }
1<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>core/play/src/main/java-scala-2.13+/play/libs/CrossScala.java<CODESPLIT>Converts a Java varargs to Scala varargs .<CODESPLIT>@ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... array ) { return toSeq ( array ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/WebSocket.java<CODESPLIT>core/play/src/main/java/play/mvc/WebSocket.java<CODESPLIT>Acceptor for JSON WebSockets .<CODESPLIT>public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
1<CODESPLIT>core/play/src/main/java/play/mvc/WebSocket.java<CODESPLIT>core/play/src/main/java/play/mvc/WebSocket.java<CODESPLIT>Helper to create handlers for WebSockets .<CODESPLIT>private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>XXX Default access superclass workaround .<CODESPLIT>static boolean setAccessibleWorkaround ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return false ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( true ) ; return true ; } catch ( final SecurityException e ) { // NOPMD // ignore in favor of subsequent IllegalAccessException } } return false ; }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>Gets the number of steps required to promote a primitive number to another type .<CODESPLIT>private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) { // slight unwrapping penalty cost += 0.1f ; cls = ClassUtils . wrapperToPrimitive ( cls ) ; } for ( int i = 0 ; cls != destClass && i < ORDERED_PRIMITIVE_TYPES . length ; i ++ ) { if ( cls == ORDERED_PRIMITIVE_TYPES [ i ] ) { cost += 0.1f ; if ( i < ORDERED_PRIMITIVE_TYPES . length - 1 ) { cls = ORDERED_PRIMITIVE_TYPES [ i + 1 ] ; } } } return cost ; }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>Returns the sum of the object transformation cost for each class in the source argument list .<CODESPLIT>private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ; // "source" and "destination" are the actual and declared args respectively. float totalCost = 0.0f ; final long normalArgsLen = isVarArgs ? destArgs . length - 1 : destArgs . length ; if ( srcArgs . length < normalArgsLen ) { return Float . MAX_VALUE ; } for ( int i = 0 ; i < normalArgsLen ; i ++ ) { totalCost += getObjectTransformationCost ( srcArgs [ i ] , destArgs [ i ] ) ; } if ( isVarArgs ) { // When isVarArgs is true, srcArgs and dstArgs may differ in length. // There are two special cases to consider: final boolean noVarArgsPassed = srcArgs . length < destArgs . length ; final boolean explicitArrayForVarags = srcArgs . length == destArgs . length && srcArgs [ srcArgs . length - 1 ] . isArray ( ) ; final float varArgsCost = 0.001f ; final Class < ? > destClass = destArgs [ destArgs . length - 1 ] . getComponentType ( ) ; if ( noVarArgsPassed ) { // When no varargs passed, the best match is the most generic matching type, not the most // specific. totalCost += getObjectTransformationCost ( destClass , Object . class ) + varArgsCost ; } else if ( explicitArrayForVarags ) { final Class < ? > sourceClass = srcArgs [ srcArgs . length - 1 ] . getComponentType ( ) ; totalCost += getObjectTransformationCost ( sourceClass , destClass ) + varArgsCost ; } else { // This is typical varargs case. for ( int i = destArgs . length - 1 ; i < srcArgs . length ; i ++ ) { final Class < ? > srcClass = srcArgs [ i ] ; totalCost += getObjectTransformationCost ( srcClass , destClass ) + varArgsCost ; } } } return totalCost ; }
1<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>core/play/src/main/java/play/libs/reflect/MemberUtils.java<CODESPLIT>Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .<CODESPLIT>private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { // slight penalty for interface match. // we still want an exact match to override an interface match, // but // an interface match should override anything where we have to // get a superclass. cost += 0.25f ; break ; } cost ++ ; srcClass = srcClass . getSuperclass ( ) ; } /*      * If the destination class is null, we've traveled all the way up to      * an Object match. We'll penalize this by adding 1.5 to the cost.      */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesImpl.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesImpl.java<CODESPLIT>Get the message at the given key .<CODESPLIT>public String at ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
1<CODESPLIT>core/play/src/main/java/play/i18n/MessagesImpl.java<CODESPLIT>core/play/src/main/java/play/i18n/MessagesImpl.java<CODESPLIT>Get the message at the first defined key .<CODESPLIT>public String at ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
1<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/Databases.java<CODESPLIT>persistence/play-java-jdbc/src/main/java/play/db/Databases.java<CODESPLIT>Create a pooled database named default with the given configuration .<CODESPLIT>public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .<CODESPLIT>public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>Sort the arrays using the quicksort algorithm .<CODESPLIT>public void quickSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/util/ParallelSorter.java<CODESPLIT>Sort the arrays using an in - place merge sort .<CODESPLIT>public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/MethodProxy.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/MethodProxy.java<CODESPLIT>Invoke the original method on a different object of the same type .<CODESPLIT>public Object invoke ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>Casts from one primitive numeric type to another<CODESPLIT>public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>Pushes the specified argument of the current method onto the stack .<CODESPLIT>public void load_arg ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>package - protected for EmitUtils try to fix<CODESPLIT>void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .<CODESPLIT>public void zero_or_null ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/CodeEmitter.java<CODESPLIT>Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .<CODESPLIT>public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/EmitUtils.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/EmitUtils.java<CODESPLIT>Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .<CODESPLIT>public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/EmitUtils.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/EmitUtils.java<CODESPLIT>If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .<CODESPLIT>private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/BridgeMethodResolver.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/BridgeMethodResolver.java<CODESPLIT>Finds all bridge methods that are being called with invokespecial & returns them .<CODESPLIT>public Map /*<Signature, Signature>*/ resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java<CODESPLIT>Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .<CODESPLIT>public static void getMethods ( Class superclass , Class [ ] interfaces , List methods ) { getMethods ( superclass , interfaces , methods , null , null ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/Enhancer.java<CODESPLIT>Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .<CODESPLIT>protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , true ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/beans/BeanGenerator.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/beans/BeanGenerator.java<CODESPLIT>Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .<CODESPLIT>public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/transform/impl/FieldProviderTransformer.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/transform/impl/FieldProviderTransformer.java<CODESPLIT>to avoid JVM hashcode implementation incompatibilities<CODESPLIT>private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/InterfaceMaker.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/proxy/InterfaceMaker.java<CODESPLIT>Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .<CODESPLIT>public void add ( Method method ) { add ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/TinyBitSet.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/TinyBitSet.java<CODESPLIT>If bit 31 is set then this method results in an infinite loop .<CODESPLIT>public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/AbstractClassGenerator.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/AbstractClassGenerator.java<CODESPLIT>Override the default naming policy .<CODESPLIT>public void setNamingPolicy ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
1<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/ReflectUtils.java<CODESPLIT>cglib/src/main/java/net/sf/cglib/core/ReflectUtils.java<CODESPLIT>used by MethodInterceptorGenerated generated code<CODESPLIT>public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) { // TODO: error? } } return result ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/PathUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/PathUtil.java<CODESPLIT>Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .<CODESPLIT>public static Path resolve ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/PathUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/PathUtil.java<CODESPLIT>Reads path content .<CODESPLIT>public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ; // flush & close not needed for StringWriter-instance StreamUtil . copy ( reader , writer ) ; return writer . toString ( ) ; } }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Sets request host name .<CODESPLIT>public HttpRequest host ( final String host ) { this . host = host ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , host ) ; } return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .<CODESPLIT>public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a CONNECT request .<CODESPLIT>public static HttpRequest connect ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a GET request .<CODESPLIT>public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a POST request .<CODESPLIT>public static HttpRequest post ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a PUT request .<CODESPLIT>public static HttpRequest put ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a PATCH request .<CODESPLIT>public static HttpRequest patch ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a DELETE request .<CODESPLIT>public static HttpRequest delete ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a HEAD request .<CODESPLIT>public static HttpRequest head ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds a TRACE request .<CODESPLIT>public static HttpRequest trace ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Builds an OPTIONS request .<CODESPLIT>public static HttpRequest options ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( destination ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .<CODESPLIT>public HttpRequest path ( String path ) { // this must be the only place that sets the path if ( ! path . startsWith ( StringPool . SLASH ) ) { path = StringPool . SLASH + path ; } int ndx = path . indexOf ( ' ' ) ; if ( ndx != - 1 ) { String queryString = path . substring ( ndx + 1 ) ; path = path . substring ( 0 , ndx ) ; query = HttpUtil . parseQuery ( queryString , true ) ; } else { query = HttpMultiMap . newCaseInsensitiveMap ( ) ; } this . path = path ; return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Sets cookies to the request .<CODESPLIT>public HttpRequest cookies ( final Cookie ... cookies ) { if ( cookies . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = true ; for ( Cookie cookie : cookies ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = false ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Adds many query parameters at once . Although it accepts objects each value will be converted to string .<CODESPLIT>public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Adds all parameters from the provided map .<CODESPLIT>public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { query . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Sets query from provided query string . Previous query values are discarded .<CODESPLIT>public HttpRequest queryString ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( queryString , decode ) ; return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Generates query string . All values are URL encoded .<CODESPLIT>public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Returns just host url without path and query .<CODESPLIT>public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Enables basic authentication by adding required header .<CODESPLIT>public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Sets Host header from current host and port .<CODESPLIT>public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Prepares the request buffer .<CODESPLIT>@ Override protected Buffer buffer ( final boolean fullRequest ) { // INITIALIZATION // host port if ( header ( HEADER_HOST ) == null ) { setHostHeader ( ) ; } // form Buffer formBuffer = formBuffer ( ) ; // query string String queryString = queryString ( ) ; // user-agent if ( header ( "User-Agent" ) == null ) { header ( "User-Agent" , Defaults . userAgent ) ; } // POST method requires Content-Type to be set if ( method . equals ( "POST" ) && ( contentLength ( ) == null ) ) { contentLength ( 0 ) ; } // BUILD OUT Buffer request = new Buffer ( ) ; request . append ( method ) . append ( SPACE ) . append ( path ) ; if ( query != null && ! query . isEmpty ( ) ) { request . append ( ' ' ) ; request . append ( queryString ) ; } request . append ( SPACE ) . append ( httpVersion ) . append ( CRLF ) ; populateHeaderAndBody ( request , formBuffer , fullRequest ) ; return request ; }
1<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>jodd-http/src/main/java/jodd/http/HttpRequest.java<CODESPLIT>Syntax sugar .<CODESPLIT>public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/asm7/Handler.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/asm7/Handler.java<CODESPLIT>Removes the range between start and end from the Handler list that begins with the given element .<CODESPLIT>static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ; // Return early if [handlerStart,handlerEnd[ and [rangeStart,rangeEnd[ don't intersect. if ( rangeStart >= handlerEnd || rangeEnd <= handlerStart ) { return firstHandler ; } if ( rangeStart <= handlerStart ) { if ( rangeEnd >= handlerEnd ) { // If [handlerStart,handlerEnd[ is included in [rangeStart,rangeEnd[, remove firstHandler. return firstHandler . nextHandler ; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [rangeEnd,handlerEnd[ return new Handler ( firstHandler , end , firstHandler . endPc ) ; } } else if ( rangeEnd >= handlerEnd ) { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = [handlerStart,rangeStart[ return new Handler ( firstHandler , firstHandler . startPc , start ) ; } else { // [handlerStart,handlerEnd[ - [rangeStart,rangeEnd[ = //     [handlerStart,rangeStart[ + [rangeEnd,handerEnd[ firstHandler . nextHandler = new Handler ( firstHandler , end , firstHandler . endPc ) ; return new Handler ( firstHandler , firstHandler . startPc , start ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/asm7/Handler.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/asm7/Handler.java<CODESPLIT>Returns the number of elements of the Handler list that begins with the given element .<CODESPLIT>static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>Collects all interceptors .<CODESPLIT>protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>Collects all filters .<CODESPLIT>protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>Collects all action results .<CODESPLIT>protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/action/MadvocConfigurations.java<CODESPLIT>Collects all action runtime configurations .<CODESPLIT>protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>Sets a value of simple property .<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ; // try: setter if ( setter != null ) { invokeSetter ( setter , bp , value ) ; return ; } // try: put("property", value) if ( bp . isMap ( ) ) { ( ( Map ) bp . bean ) . put ( bp . name , value ) ; return ; } if ( isSilent ) { return ; } throw new BeanException ( "Simple property not found: " + bp . name , bp ) ; }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>Returns value of bean s property .<CODESPLIT>@ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanUtilBean.java<CODESPLIT>Extract the first name of this reference .<CODESPLIT>@ Override public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/filter/CharArrayResponseWrapper.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/filter/CharArrayResponseWrapper.java<CODESPLIT>Returns buffered writer . Buffer will be created if not already used .<CODESPLIT>@ Override public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Saves object reference .<CODESPLIT>public void setObjectReference ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Returns object reference .<CODESPLIT>public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Lookups for object reference and throws an exception if reference doesn t exist .<CODESPLIT>public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Returns entity descriptor for provided table reference .<CODESPLIT>public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . desc ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Finds entity descriptor of a table that contains provided column reference .<CODESPLIT>public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Returns table alias for provided table reference .<CODESPLIT>public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Registers table reference for provided entity .<CODESPLIT>public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Lookups for table reference and throws an exception if table reference not found .<CODESPLIT>protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/TemplateData.java<CODESPLIT>Registers a hint .<CODESPLIT>public void registerHint ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
1<CODESPLIT>jodd-json/src/main/java/jodd/json/impl/ValueJsonSerializer.java<CODESPLIT>jodd-json/src/main/java/jodd/json/impl/ValueJsonSerializer.java<CODESPLIT>Detects circular dependencies and pushes value as current type context .<CODESPLIT>@ Override public final boolean serialize ( final JsonContext jsonContext , final T value ) { if ( jsonContext . pushValue ( value ) ) { // prevent circular dependencies return false ; } serializeValue ( jsonContext , value ) ; jsonContext . popValue ( ) ; return true ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>Injects request attributes .<CODESPLIT>protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , true ) ; } } ) ; } }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>Inject request parameters .<CODESPLIT>protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , true ) ; } } } ) ; } }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/scope/RequestScope.java<CODESPLIT>Inject uploaded files from multipart request parameters .<CODESPLIT>protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , true ) ; } } ) ; } }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>Converts property name to column name .<CODESPLIT>public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>Converts column name to property name .<CODESPLIT>public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = false ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = true ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = false ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/naming/ColumnNamingStrategy.java<CODESPLIT>Applies column naming strategy to given column name hint . Returns full column name .<CODESPLIT>public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/type/SqlType.java<CODESPLIT>jodd-db/src/main/java/jodd/db/type/SqlType.java<CODESPLIT>Stores value in database . Value is casted to sql type .<CODESPLIT>public void storeValue ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/type/SqlType.java<CODESPLIT>jodd-db/src/main/java/jodd/db/type/SqlType.java<CODESPLIT>Once when value is read from result set prepare it to match destination type .<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) protected < E > E prepareGetValue ( final T t , final Class < E > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( E ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>Returns all action wrappers . Returns a copy in new set .<CODESPLIT>protected Set < T > getAll ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .<CODESPLIT>public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/WrapperManager.java<CODESPLIT>Creates new wrapper .<CODESPLIT>protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>Converts all separators to the system separator .<CODESPLIT>public static String separatorsToSystem ( final String path ) { if ( path == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( path ) ; } else { return separatorsToUnix ( path ) ; } }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>Does the work of getting the path .<CODESPLIT>private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .<CODESPLIT>public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>jodd-core/src/main/java/jodd/io/FileNameUtil.java<CODESPLIT>Calculates relative path of target path on base path .<CODESPLIT>public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>Registers additional Madvoc components after the registration of default components .<CODESPLIT>public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>Configures the action configurations .<CODESPLIT>public < A extends ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>Initializes and starts web application .<CODESPLIT>public WebApp start ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ; //// params & props for ( final Map < String , Object > params : paramsList ) { madvocContainer . defineParams ( params ) ; } for ( final Props props : propsList ) { madvocContainer . defineParams ( props ) ; } propsList = null ; //// components registerMadvocComponents ( ) ; madvocComponents . forEach ( madvocComponent -> madvocContainer . registerComponent ( madvocComponent . type ( ) , madvocComponent . consumer ( ) ) ) ; madvocComponents = null ; madvocComponentInstances . forEach ( madvocContainer :: registerComponentInstance ) ; madvocComponentInstances = null ; configureDefaults ( ) ; //// listeners madvocContainer . fireEvent ( Init . class ) ; //// component configuration componentConfigs . accept ( madvocContainer ) ; componentConfigs = null ; initialized ( ) ; madvocContainer . fireEvent ( Start . class ) ; if ( ! madvocRouterConsumers . isEmpty ( ) ) { final MadvocRouter madvocRouter = MadvocRouter . create ( ) ; madvocContainer . registerComponentInstance ( madvocRouter ) ; madvocRouterConsumers . accept ( madvocRouter ) ; } madvocRouterConsumers = null ; started ( ) ; madvocContainer . fireEvent ( Ready . class ) ; ready ( ) ; return this ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>Configure defaults .<CODESPLIT>protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/WebApp.java<CODESPLIT>Registers default Madvoc components .<CODESPLIT>protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Specify excluded jars .<CODESPLIT>public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Specify included jars .<CODESPLIT>public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Sets included set of names that will be considered during configuration .<CODESPLIT>public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Sets excluded names that narrows included set of packages .<CODESPLIT>public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Scans classes inside single JAR archive . Archive is scanned as a zip file .<CODESPLIT>protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , true ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , false ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Scans single classpath directory .<CODESPLIT>protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( false ) . recursive ( true ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , true ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , false ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Returns type signature bytes used for searching in class file .<CODESPLIT>public static byte [ ] bytecodeSignatureOfType ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Scans provided paths .<CODESPLIT>public ClassScanner scan ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>jodd-core/src/main/java/jodd/io/findfile/ClassScanner.java<CODESPLIT>Starts with the scanner .<CODESPLIT>public void start ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/jtx/DbJtxTransactionManager.java<CODESPLIT>jodd-db/src/main/java/jodd/db/jtx/DbJtxTransactionManager.java<CODESPLIT>Builds new transaction instance .<CODESPLIT>@ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < S extends MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>Performs search for the scope class and returns it s instance .<CODESPLIT>protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( madvocScopeType ) ) { return s ; } } // new scope detected final MadvocScope newScope ; try { newScope = madpc . createBean ( madvocScopeType ) ; } catch ( Exception ex ) { throw new MadvocException ( "Unable to create scope: " + madvocScopeType , ex ) ; } allScopes . add ( newScope ) ; return newScope ; }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/component/ScopeResolver.java<CODESPLIT>Finds a given scope and consumes it .<CODESPLIT>public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope scope = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( scope ) ; }
1<CODESPLIT>jodd-core/src/main/java/jodd/util/Base64.java<CODESPLIT>jodd-core/src/main/java/jodd/util/Base64.java<CODESPLIT>Decodes a BASE64 encoded char array .<CODESPLIT>public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>Generates new CSRF token and puts it in the session . Returns generated token value .<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>Removes expired tokens if token set is full .<CODESPLIT>protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/CsrfShield.java<CODESPLIT>Checks token value . C<CODESPLIT>@ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return true ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return false ; } boolean found = false ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = true ; } } return found ; }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>Defines source detects a map .<CODESPLIT>public static BeanCopy from ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>Performs the copying .<CODESPLIT>public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( true ) ; visit ( ) ; }
1<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>jodd-bean/src/main/java/jodd/bean/BeanCopy.java<CODESPLIT>Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .<CODESPLIT>@ Override protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return true ; }
1<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/chunks/TableChunk.java<CODESPLIT>jodd-db/src/main/java/jodd/db/oom/sqlgen/chunks/TableChunk.java<CODESPLIT>Resolves and registers table references .<CODESPLIT>@ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Resolves and registers scope from a scope type .<CODESPLIT>@ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers or defines a bean .<CODESPLIT>public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; } // remove existing bean BeanDefinition existing = removeBean ( name ) ; if ( existing != null ) { if ( petiteConfig . getDetectDuplicatedBeanNames ( ) ) { throw new PetiteException ( "Duplicated bean name detected while registering class '" + type . getName ( ) + "'. Petite bean class '" + existing . type . getName ( ) + "' is already registered with the name: " + name ) ; } } // check if type is valid if ( type . isInterface ( ) ) { throw new PetiteException ( "PetiteBean can not be an interface: " + type . getName ( ) ) ; } // registration if ( log . isDebugEnabled ( ) ) { log . info ( "Petite bean: [" + name + "] --> " + type . getName ( ) + " @ " + scopeType . getSimpleName ( ) + ":" + wiringMode . toString ( ) ) ; } // register Scope scope = resolveScope ( scopeType ) ; BeanDefinition < T > beanDefinition = createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; registerBean ( name , beanDefinition ) ; // providers ProviderDefinition [ ] providerDefinitions = petiteResolvers . resolveProviderDefinitions ( type , name ) ; if ( providerDefinitions != null ) { for ( ProviderDefinition providerDefinition : providerDefinitions ) { providers . put ( providerDefinition . name , providerDefinition ) ; } } // define if ( define ) { beanDefinition . ctor = petiteResolvers . resolveCtorInjectionPoint ( beanDefinition . type ( ) ) ; beanDefinition . properties = PropertyInjectionPoint . EMPTY ; beanDefinition . methods = MethodInjectionPoint . EMPTY ; beanDefinition . initMethods = InitMethodPoint . EMPTY ; beanDefinition . destroyMethods = DestroyMethodPoint . EMPTY ; } // return return beanDefinition ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .<CODESPLIT>protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ; // store null as value to mark that alt name is duplicate } } else { beansAlt . put ( altName , beanDefinition ) ; } } }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .<CODESPLIT>public void removeBean ( final Class type ) { // collect bean names Set < String > beanNames = new HashSet <> ( ) ; for ( BeanDefinition def : beans . values ( ) ) { if ( def . type . equals ( type ) ) { beanNames . add ( def . name ) ; } } // remove collected bean names for ( String beanName : beanNames ) { removeBean ( beanName ) ; } }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Resolves bean names for give type .<CODESPLIT>protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers constructor injection point .<CODESPLIT>public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , true ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers property injection point .<CODESPLIT>public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers set injection point .<CODESPLIT>public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , true ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers method injection point .<CODESPLIT>public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers init method .<CODESPLIT>public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers destroy method .<CODESPLIT>public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , true ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers instance method provider .<CODESPLIT>public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Registers static method provider .<CODESPLIT>public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( staticMethodName , arguments , true ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Iterates all beans that are of given type .<CODESPLIT>public void forEachBeanType ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
1<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>jodd-petite/src/main/java/jodd/petite/PetiteBeans.java<CODESPLIT>Defines many parameters at once .<CODESPLIT>public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > entry : properties . entrySet ( ) ) { defineParameter ( entry . getKey ( ) . toString ( ) , entry . getValue ( ) ) ; } }
1<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/interceptor/EchoInterceptor.java<CODESPLIT>jodd-madvoc/src/main/java/jodd/madvoc/interceptor/EchoInterceptor.java<CODESPLIT>Measure action invocation time .<CODESPLIT>@ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , result ) ; } return result ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Resolves Java version from current version .<CODESPLIT>public static int resolveJavaVersion ( final int version ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return version > platformVersion ? version : platformVersion ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Pushes int value in an optimal way .<CODESPLIT>public static void pushInt ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Validates argument index .<CODESPLIT>public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Builds advice field name .<CODESPLIT>public static String adviceFieldName ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Builds advice method name .<CODESPLIT>public static String adviceMethodName ( final String name , final int index ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + index ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Loads all method arguments before INVOKESPECIAL call .<CODESPLIT>public static void loadSpecialMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Loads all method arguments before INVOKESTATIC call .<CODESPLIT>public static void loadStaticMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Loads all method arguments before INVOKEVIRTUAL call .<CODESPLIT>public static void loadVirtualMethodArguments ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Loads one argument . Index is 1 - based . No conversion occurs .<CODESPLIT>public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Stores one argument . Index is 1 - based . No conversion occurs .<CODESPLIT>public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Prepares return value .<CODESPLIT>public static void prepareReturnValue ( final MethodVisitor mv , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : mv . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( mv ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( mv ) ; break ; case ' ' : AsmUtil . valueOfShort ( mv ) ; break ; case ' ' : AsmUtil . valueOfInteger ( mv ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( mv ) ; break ; case ' ' : AsmUtil . valueOfLong ( mv ) ; break ; case ' ' : AsmUtil . valueOfFloat ( mv ) ; break ; case ' ' : AsmUtil . valueOfDouble ( mv ) ; break ; } }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Creates unique key for method signatures map .<CODESPLIT>public static String createMethodSignaturesKey ( final int access , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Creates new array .<CODESPLIT>public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
1<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>jodd-proxetta/src/main/java/jodd/proxetta/asm/ProxettaAsmUtil.java<CODESPLIT>Stores element on stack into an array .<CODESPLIT>public static void storeIntoArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
1<CODESPLIT>jodd-mail/src/main/java/jodd/mail/EmailUtil.java<CODESPLIT>jodd-mail/src/main/java/jodd/mail/EmailUtil.java<CODESPLIT>Extracts encoding from a given content type .<CODESPLIT>public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
1<CODESPLIT>jodd-mail/src/main/java/jodd/mail/EmailUtil.java<CODESPLIT>jodd-mail/src/main/java/jodd/mail/EmailUtil.java<CODESPLIT>Check whether flags is a empty flags<CODESPLIT>public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return true ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return false ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return false ; } return true ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>Returns Bearer token .<CODESPLIT>public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>Sends correct headers to require basic authentication for the given realm .<CODESPLIT>public static void requireAuthentication ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>Prepares response for file download with provided mime type .<CODESPLIT>public static void prepareDownload ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
1<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>jodd-servlet/src/main/java/jodd/servlet/ServletUtil.java<CODESPLIT>Prepares response for various provided data .<CODESPLI